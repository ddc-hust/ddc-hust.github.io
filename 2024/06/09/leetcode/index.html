<!DOCTYPE html><html lang="zh CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法 | 初澈@Blog</title><meta name="author" content="初澈"><meta name="copyright" content="初澈"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JS知识点1. JS除法“&#x2F;” 返回的是小数，不会取整。取整的方法：  Math.round()：四舍五入 Math.floor()：向下取整 Math.ceil()：向上取整    2. js数组排序： 使用sort方法，sort方法可以将数组中的元素转化为string类型进行比较。如果是对数num进行排序的话，需要在参数中传入比较函数  12let nums &#x3D; [1,10,5];n">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="https://ddc-hust.github.io/2024/06/09/leetcode/index.html">
<meta property="og:site_name" content="初澈@Blog">
<meta property="og:description" content="JS知识点1. JS除法“&#x2F;” 返回的是小数，不会取整。取整的方法：  Math.round()：四舍五入 Math.floor()：向下取整 Math.ceil()：向上取整    2. js数组排序： 使用sort方法，sort方法可以将数组中的元素转化为string类型进行比较。如果是对数num进行排序的话，需要在参数中传入比较函数  12let nums &#x3D; [1,10,5];n">
<meta property="og:locale">
<meta property="og:image" content="https://ddc-hust.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-06-09T06:06:50.231Z">
<meta property="article:modified_time" content="2024-06-15T09:02:22.733Z">
<meta property="article:author" content="初澈">
<meta property="article:tag" content="技术博客，前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ddc-hust.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ddc-hust.github.io/2024/06/09/leetcode/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-15 17:02:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top_img/index.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="初澈@Blog"><span class="site-name">初澈@Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-09T06:06:50.231Z" title="Created 2024-06-09 14:06:50">2024-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-06-15T09:02:22.733Z" title="Updated 2024-06-15 17:02:22">2024-06-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h2><h3 id="1-JS除法“-”"><a href="#1-JS除法“-”" class="headerlink" title="1. JS除法“&#x2F;”"></a>1. <strong>JS除法“&#x2F;”</strong></h3><ul>
<li><p>返回的是小数，不会取整。取整的方法：</p>
<ul>
<li>Math.round()：四舍五入</li>
<li>Math.floor()：向下取整</li>
<li>Math.ceil()：向上取整</li>
</ul>
</li>
</ul>
<h3 id="2-js数组排序："><a href="#2-js数组排序：" class="headerlink" title="2. js数组排序："></a>2. j<strong>s数组排序</strong>：</h3><ul>
<li>使用sort方法，sort方法可以将数组中的元素转化为string类型进行比较。如果是对数num进行排序的话，需要在参数中传入比较函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>];</span><br><span class="line">nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)	<span class="comment">// a小于b的话，返回负值；a大于b的话，返回正值；a等于b的话，返回0</span></span><br></pre></td></tr></table></figure>

<h3 id="3-js创建二维数组："><a href="#3-js创建二维数组：" class="headerlink" title="3. js创建二维数组："></a>3. <strong>js创建二维数组</strong>：</h3><ul>
<li><p>使用Array.from()函数（from函数是ES6新增的创建数组的静态方法）。from函数用于将类数组结构转换为数组结构。from函数可以接收第二个参数，用于增强新数组的值，（新数组中的每一个值都会执行该回调函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>), <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">let</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>().<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>())<span class="comment">//注意这里用了fill(),参数为空填充的是undefined</span></span><br><span class="line"><span class="keyword">let</span> nums = []</span><br></pre></td></tr></table></figure>

<ul>
<li>当一个对象被传递给 <code>fill</code> 方法的时候，填充数组的是这个对象的引用。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>string类型不可变</p>
</li>
<li><p>需要注意的是，<strong>js中的字符串是不可变的。</strong>如果想要对字符串赋值，必须生成新的字符串。</p>
<ul>
<li><p>这里采用**s.split(“”)**的方法，将字符串按照字符进行拆分，得到数组</p>
</li>
<li><p>再使用**arr.join(“”)**的方法，将数组中的各元素连接起来，生成字符串</p>
</li>
</ul>
</li>
</ol>
<h3 id="4-js数组拷贝"><a href="#4-js数组拷贝" class="headerlink" title="4. js数组拷贝"></a>4. js数组拷贝</h3><ul>
<li><p>向二维数组中push一维数组，不可以直接arr2.puhs(arr1),  这样是浅拷贝，push的是引用地址，没有用。要深拷贝，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.<span class="title function_">push</span>([...queue]);    <span class="comment">//注意点，要深拷贝，不可以写res.push(queue)，三个点是解构</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-字符编码"><a href="#5-字符编码" class="headerlink" title="5. 字符编码"></a>5. <strong>字符编码</strong></h3><ul>
<li><p>JS中使用charCodeAt()函数可以查看指定索引位置的码元值，UNICODE编码，</p>
</li>
<li><p>Unicode编码中</p>
<ul>
<li>A-Z： 65 - 90</li>
<li>a-z：97 - 122</li>
<li>0 - 9：48 - 57</li>
</ul>
</li>
<li><p>应用：leetcode125：验证回文串</p>
</li>
<li><pre><code class="javascript">var isPalindrome = function(s) &#123;
    var i = 0, j = s.length - 1;
    while(i &lt; j) &#123;
        while(!isNumLetter(s[i].toLowerCase().charCodeAt(0)) &amp;&amp; i &lt; j) &#123;
            i++;
        &#125;
        while(!isNumLetter(s[j].toLowerCase().charCodeAt(0)) &amp;&amp; i &lt; j) &#123;
            j--;
        &#125;
        if(s[i].toLowerCase().charCodeAt(0) != s[j].toLowerCase().charCodeAt(0)) &#123;
            return false;
        &#125;
        i++;j--;
    &#125;
    return true;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   * toUpperCase()这类函数返回的是新的string字符串</span><br><span class="line"></span><br><span class="line">   * 判断一个字符是否是数字或者字符，可以通过使用unicode编码的方式判断。找到0和a的编码，然后用当前字符的编码减去base编码，如果在一定的范围内，则是字符或者数字。</span><br><span class="line"></span><br><span class="line">### 6. 值的范围</span><br><span class="line"></span><br><span class="line">* 最大值：`Number.MAX_VALUE`  ,   `infinity`</span><br><span class="line">* 最小值：`Number.MIN_VALUE`（这个最小值表示的是最小正数，如果需要表示范围的话，需要使用-Number.MAX_VALUE）  ,   `-infinity`</span><br><span class="line"></span><br><span class="line">### 7. 数组的splice函数</span><br><span class="line"></span><br><span class="line">* splice函数用于删除、插入、替换数组的元素（可实现在数组的任意位置添加指定数量的元素，在数组的任意位置删除指定数量的元素）</span><br><span class="line">* 三个参数：</span><br><span class="line">  1. 指定删除或插入元素数组的位置</span><br><span class="line">  2. 删除元素的个数。为0代表不删除元素</span><br><span class="line">  3. 第三个参数可选，替换元素</span><br><span class="line">* inplace操作，直接修改原数组（sort函数也是）</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">queue.splice(index, 0, people[i])</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="8-生成随机数"><a href="#8-生成随机数" class="headerlink" title="8. 生成随机数"></a>8. 生成随机数</h3><ul>
<li>生成start到end的随机数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (end - start + <span class="number">1</span>) ) + start;<span class="comment">//注意这里的加1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()* <span class="number">9</span> + <span class="number">2</span>);<span class="comment">//生成2到10之间的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成5到40之间的整数</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">36</span>)) + <span class="number">5</span><span class="comment">//这里乘36是因为，Math.random不能生成1,乘于36后会生成0到36之间的数，但是不包含36。最后使用Math.round()函数就可以向下取整。最终产生5到40之间的整数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Math.random()生成0到1.0之间的随机数。包含0但是不包含1。，Math.round()四舍五入</li>
</ul>
<h3 id="9-正则表达式"><a href="#9-正则表达式" class="headerlink" title="9. 正则表达式"></a>9. 正则表达式</h3><ul>
<li><p><code>\W等价于[^0-9A-Za-z_]</code>，replace函数中可以替换正则表达式匹配的子字符串</p>
</li>
<li><pre><code class="js">   //126, 力扣替换字符串的题目，也可以使用正则表达式，\W等价于[^0-9A-Za-z_]
    //本题将所有的不是字符的数替换掉，只留下字符数字
    let res  = s.replace(/\W|_/g, &quot;&quot;).toLowerCase();
    let t = res.split(&quot;&quot;).reverse().join(&quot;&quot;);
    return res === t;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">## 数组</span><br><span class="line"></span><br><span class="line">### 1. 二分查找</span><br><span class="line"></span><br><span class="line">* **使用前提：**二分查找前提有两个：1是数组为有序数组；2是数组中无重复元素</span><br><span class="line"></span><br><span class="line">* **重点：**把握区间的定义，区间的定义就是不变量</span><br><span class="line"></span><br><span class="line">* **详细方法**：对于区间左闭右闭的情况：</span><br><span class="line"></span><br><span class="line">  * while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</span><br><span class="line">  * if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</span><br><span class="line"></span><br><span class="line">* **例题**：704.二分查找</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  var search = function(nums, target) &#123;</span><br><span class="line">      var left = 0, right = nums.length-1, mid;</span><br><span class="line">      while (left &lt;= right) &#123;</span><br><span class="line">          mid = Math.floor((left+right) / 2);</span><br><span class="line">          if (nums[mid] &lt; target) &#123;</span><br><span class="line">              left = mid + 1;</span><br><span class="line">          &#125;else if (nums[mid] &gt; target) &#123;</span><br><span class="line">              right = mid - 1;</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">              return mid;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>例题：34.在排序数组中查找元素的第一个和最后一个位置</p>
<ul>
<li>该方法分别利用二分查找方法寻找左边界和右边界</li>
</ul>
</li>
</ul>
<h3 id="二分查找确定左右边界"><a href="#二分查找确定左右边界" class="headerlink" title="二分查找确定左右边界"></a>二分查找确定左右边界</h3><ul>
<li>当数组中有重复元素，查找重复元素的左边界的时候，判断的条件：<code>nums[mid] &gt;= target</code> , 这个时候更新<code>right</code>，那么<code>right</code>就是左边界的下一个</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params"> nums ,  target </span>) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//中间分割点的判断条件变了，本题数组中有重复数字，那么mid就不能简单将数组分为大于和小于两部分。应该分成小于和大于等于。这样的话，最后一定</span></span><br><span class="line">   <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>, leftBorder = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">     <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left)/<span class="number">2</span>);</span><br><span class="line">     <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">        leftBorder = mid-<span class="number">1</span> ;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> nums[leftBorder + <span class="number">1</span>] === target? leftBorder + <span class="number">1</span> : -<span class="number">1</span>;<span class="comment">//注意这里最后是leftBorder+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchRange = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">//分别查找左边界和右边界，先找左边界，最后如果左边界没找到的话，就代表没有找到该元素，返回-1，-1。否则就找有边界</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>, leftBorder = -<span class="number">1</span>, rightBorder = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [-<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid -<span class="number">1</span>;</span><br><span class="line">            leftBorder = right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[leftBorder + <span class="number">1</span>] !== target) <span class="keyword">return</span> result;</span><br><span class="line">    result[<span class="number">0</span>] = leftBorder + <span class="number">1</span>;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">            rightBorder = left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result[<span class="number">1</span>] = rightBorder - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>* </p>
<h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2. 移除元素"></a>2. 移除元素</h3><ul>
<li><p>移除数组中的指定元素，需考虑数组中删除元素只能覆盖</p>
</li>
<li><p><strong>例题：</strong> 27. 移除元素</p>
<ul>
<li>方法：采用快慢指针的方法，慢指针指向新数组的元素，快指针用于筛选新数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针，low指针指向结果数组，fast指针指向nums数组</span></span><br><span class="line"><span class="comment"> * fast指针判断curValue是否等于val，如果等于val，则fast++，直到curValue!=val</span></span><br><span class="line"><span class="comment"> * 然后把fast指向的val赋值给low</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> low = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">            nums[low] = nums[fast];</span><br><span class="line">            low++;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>例题：</strong>977. 有序数组的平方</p>
<ul>
<li>方法：考虑到数组的有序，以0为分割点，分为两段采用<strong>归并排序</strong>的方法</li>
<li>也可使用双指针法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目的是找到平方之后的顺序，需要注意的是，数组正数和负数都是有序的</span></span><br><span class="line"><span class="comment"> * 平方之后，最大值一定是在数组的两端取的，所以设置双指针，分别指向数组的头和尾</span></span><br><span class="line"><span class="comment"> * 依次向中遍历，取最大值放在结果数组的末端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//双指针的解法</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> k = nums.<span class="property">length</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">let</span> iSqure = nums[i] * nums[i];</span><br><span class="line">        <span class="keyword">let</span> jSqure = nums[j] * nums[j];</span><br><span class="line">        <span class="keyword">if</span>(iSqure &gt;= jSqure) &#123;</span><br><span class="line">            result[k] = iSqure;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result[k] = jSqure;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-长度最小的子数组209"><a href="#3-长度最小的子数组209" class="headerlink" title="3. 长度最小的子数组209"></a>3. 长度最小的子数组209</h3><ul>
<li><p>找出一段子序列且大于target的子序列，返回该序列的长度。<strong>找出满足条件的最小子序列</strong></p>
</li>
<li><p><strong>方法：</strong>采用<strong>滑动窗口</strong>的方法，相当于双指针。不断更新滑动窗口的起始位置和终止位置，来更新滑动窗口数值的总和</p>
</li>
<li><p>（滑动窗口最开始是空，有两个边界确定，最开始两个边界i和j都指向0，表示窗口为空，注意是左闭右开的区间）</p>
</li>
<li><p><strong>代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i:起始位置； j:终止位置； sum子序列的和； ans子序列结果长度，初始化为最大值</span></span><br><span class="line">i = <span class="number">0</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>, ans = <span class="variable constant_">MAX</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    sum += nums[j];</span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;	<span class="comment">//满足条件之后不断的更新左指针来缩小窗口，找到最小序列</span></span><br><span class="line">        subL = j - i + <span class="number">1</span>;</span><br><span class="line">        ans = ans &gt; subL ? subL : ans;</span><br><span class="line">        sum -= num[i];	<span class="comment">//这里很重要，找到sum&gt;target后，需要更新滑动窗口，而更新滑动窗口是通过移动起始位置来更新的，</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans != <span class="variable constant_">MAX</span> ? ans : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line"><span class="keyword">let</span> len = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line"><span class="keyword">let</span> count = nums[<span class="number">0</span>];	<span class="comment">//count记录目前加和结果</span></span><br><span class="line"><span class="keyword">while</span>(j &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">    count += nums[j];</span><br><span class="line">    <span class="keyword">while</span>(count &gt;= target) &#123;	<span class="comment">//满足条件之后，不断的缩小左指针</span></span><br><span class="line">        len = j-i+<span class="number">1</span>;</span><br><span class="line">        result = <span class="title class_">Math</span>.<span class="title function_">min</span>(result, len);</span><br><span class="line">        count -= nums[i]; </span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-水果成篮904"><a href="#4-水果成篮904" class="headerlink" title="4. 水果成篮904"></a>4. <strong>水果成篮904</strong></h3><ul>
<li><p><strong>找出满足某一条件的最大子序列。</strong>该条件为保证子序列中的水果种类不超过2种</p>
</li>
<li><p>要点：滑动窗口，当不满足条件之后，不断的缩小左指针，从而找到每一种可能性。</p>
</li>
<li><p>注意点：条件的判断篮子中种类不能超过两类，给篮子建立哈希表，当篮子map的size大于2之后，即为不满足条件，这个时候就更新 i 指针。</p>
</li>
<li><p>代码：</p>
</li>
<li><pre><code class="javascript">/**
 * 采摘水果时，需要考虑当前篮子中的情况
 * 如果篮子中有该水果，则可以直接放
 * 如果篮子中没有该水果，需要判断篮子的size是否大于等于2，如果大于等于2，需要把之前的水果删掉
 *      直到size小于2，就可以放入
 * 所以篮子设置map，用map表示水果的种类以及其数量
 */
var totalFruit = function(fruits) &#123;
    let basket = new Map();
    let j = 1;
    basket.set(fruits[0], 1);
    let i = 0;
    let result = 0;
    let re = 0;
    //for(let i = 0; i &lt; fruits.length - 1; i++) &#123;
        while(j &lt; fruits.length &amp;&amp; i &lt;= j) &#123;
            let re = 0;
            if(basket.has(fruits[j])) &#123;
                basket.set(fruits[j], basket.get(fruits[j]) + 1);
            &#125;else &#123;
                while(basket.size &gt;= 2) &#123;
                    basket.set(fruits[i], basket.get(fruits[i]) - 1);
                    if(basket.get(fruits[i]) == 0) basket.delete(fruits[i]);
                    i++;//不满足条件之后，缩小左指针
                &#125;
                //i--;
                basket.set(fruits[j], 1);
            &#125;
            j++;
            basket.forEach((value, key) =&gt; &#123;
                re += value;
            &#125;);
            result = Math.max(result, re);
        &#125;    
    //&#125;
    return result;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  while (j &lt; fruits.length) &#123;</span><br><span class="line">      if(basket.has(fruits[j])) &#123;</span><br><span class="line">          basket.set(fruits[j], basket.get(fruits[j])+1);</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">          basket.set(fruits[j],1) ;</span><br><span class="line">      &#125;</span><br><span class="line">      len = j - i + 1;      </span><br><span class="line">      while(basket.size &gt; 2) &#123;      // 不满足条件之后，更新i指针，寻找另一种可能性（即以j结尾且满足条件的子序列）</span><br><span class="line">          basket.set(fruits[i],basket.get(fruits[i])-1);</span><br><span class="line">          if(basket.get(fruits[i]) == 0 )&#123;</span><br><span class="line">              basket.delete(fruits[i])</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">          len--;	// 缩小长度len</span><br><span class="line">      &#125;</span><br><span class="line">      result = len &gt; result ? len : result;</span><br><span class="line">      j++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="5-最小覆盖子串76"><a href="#5-最小覆盖子串76" class="headerlink" title="5. 最小覆盖子串76"></a>5. <strong>最小覆盖子串76</strong></h3><ul>
<li><p><strong>找出满足某一条件的最小序列。</strong>该条件为保证子序列中的字符及个数覆盖目标子串中的字符及个数</p>
</li>
<li><p><strong>要点：</strong>滑动窗口，<strong>当满足条件之后，不断的更新左指针，缩小窗口的大小，从而找到最小窗口</strong></p>
</li>
<li><p>注意点：条件的判断采用哈希表</p>
</li>
<li><p>难点：如何判断子串（当前窗口）覆盖t的所有字符？</p>
</li>
<li><p>方法：用哈希表表示t中所有的字符以及他们的个数，</p>
<p>​		   用哈希表表示当前窗口的所有字符以及他们的个数</p>
<p>​		   如果第二个动态哈希表中包含第一个哈希表中所有的字符，并且字符个数不小于t的哈希表的个数。则满足条件（覆盖t中所有字符）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题解：滑动窗口，寻找满足覆盖t中所有字符的最小子串</span></span><br><span class="line"><span class="comment"> * 难点：如何判断子串（当前窗口）覆盖t的所有字符？</span></span><br><span class="line"><span class="comment"> * 方法：用哈希表表示t中所有的字符以及他们的个数，</span></span><br><span class="line"><span class="comment"> *       用哈希表表示当前窗口的所有字符以及他们的个数</span></span><br><span class="line"><span class="comment"> *      如果第二个动态哈希表中包含第一个哈希表中所有的字符，并且字符个数不小于t的哈希表的个数</span></span><br><span class="line"><span class="comment"> *       则满足条件（覆盖t中所有字符）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minWindow = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">var</span> windowMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> c <span class="keyword">of</span> t) &#123;</span><br><span class="line">        tMap.<span class="title function_">set</span>(c, tMap.<span class="title function_">has</span>(c) ? tMap.<span class="title function_">get</span>(c) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> l = -<span class="number">1</span>, r = -<span class="number">1</span>, len = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>( j &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        windowMap.<span class="title function_">set</span>(s[j], windowMap.<span class="title function_">has</span>(s[j]) ? windowMap.<span class="title function_">get</span>(s[j]) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_">check</span>(windowMap,tMap)) &#123;</span><br><span class="line">            <span class="keyword">if</span>( len &gt; (j - i + <span class="number">1</span>)) &#123;</span><br><span class="line">                r = j;</span><br><span class="line">                l = i;</span><br><span class="line">                len = j - i + <span class="number">1</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">            windowMap.<span class="title function_">set</span>(s[i], windowMap.<span class="title function_">get</span>(s[i]) - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(windowMap.<span class="title function_">get</span>(s[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                windowMap.<span class="title function_">delete</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">substring</span>(l, r + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">windowMap, tMap</span>) &#123;<span class="comment">//检查当前滑动窗口是否覆盖t的map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> pair <span class="keyword">of</span> tMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!windowMap.<span class="title function_">has</span>(pair[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (windowMap.<span class="title function_">get</span>(pair[<span class="number">0</span>]) &lt; pair[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-螺旋矩阵"><a href="#6-螺旋矩阵" class="headerlink" title="6. 螺旋矩阵"></a>6. 螺旋矩阵</h3><ul>
<li>螺旋矩阵：考虑以圈数为切入点</li>
<li>注意圈数的个数、每一行位移的长度，最后的中间位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照左闭右开的原则，四个方向一一循环填数组</span></span><br><span class="line"><span class="comment"> * 设置offset表示每次循环移动的位数</span></span><br><span class="line"><span class="comment"> * 设置starti和startj表示画圈开始的地方</span></span><br><span class="line"><span class="comment"> * 需注意的是，当n为奇数时，最后一圈只有一个数，这是无法通过画圈来填满，需要单独赋值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * loop代表圈数，n对2取整的结果就是圈数,循环中使用loop判断是否循环完</span></span><br><span class="line"><span class="comment"> * 需注意的是，当n为奇数的时候，中间只有一个数，需要单独处理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * startX和startY代表每次圈的起点，每次循环，加加1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * offset表示每一行遍历的长度，每一圈都比上一圈加1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> loop = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">let</span> startX = <span class="number">0</span>, startY = <span class="number">0</span>;<span class="comment">//startX,</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(loop--) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = startX, j = startY;</span><br><span class="line">        <span class="comment">//上行：从左到右遍历，递增j</span></span><br><span class="line">        <span class="keyword">for</span>(; j &lt; n - offset; j++) &#123;</span><br><span class="line">            result[i][j] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右行：从上到下，递增i</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; n - offset; i++) &#123;</span><br><span class="line">            result[i][j] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下行：从右到左，递减j。注意j的起始位置是startY</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt; startY; j--) &#123;</span><br><span class="line">            result[i][j] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左行：从下往上，递减i。注意i的起始位置是startX</span></span><br><span class="line">        <span class="keyword">for</span>(; i &gt; startX; i--) &#123;</span><br><span class="line">            result[i][j] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        offset++; <span class="comment">//offset每次加1</span></span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( n%<span class="number">2</span>)  result[mid][mid] = num;<span class="comment">//当n为奇数的时候，中间有一个数需要单独赋值</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>当数组有序的时候，就考虑使用<strong>二分法</strong>，二分法注意区间的闭和开，以及mid的取值</li>
</ul>
<ol>
<li>数组常用方法：<strong>双指针，滑动窗口</strong>，归并排序（段内有序）</li>
<li>滑动窗口最重要的就是左右指针的移动，这里的3，4，5例题，需要区分寻找的是满足条件的最大子序列，还是满足条件的最小子序列。<ul>
<li>最大子序列：在不满足条件之后，需要移动左指针，更新窗口的大小，寻找每一种可能。</li>
<li>最小子序列：在满足条件之后，需要移动左指针，缩小窗口的大小，找到最小序列长度</li>
</ul>
</li>
<li>相似题：1004、3</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1. 移除链表元素"></a>1. 移除链表元素</h3><ul>
<li>设置虚拟头节点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> pre = dummyNode;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">val</span> === val) &#123;</span><br><span class="line">            pre.<span class="property">next</span> = cur.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            pre = pre.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-设计链表"><a href="#2-设计链表" class="headerlink" title="2. 设计链表"></a>2. 设计链表</h3><h3 id="3-翻转链表"><a href="#3-翻转链表" class="headerlink" title="3. 翻转链表"></a>3. 翻转链表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 逻辑：将当前节点的next指向前一个节点preNode,然后curNode移动到下一位，preNode移动到下一位</span></span><br><span class="line"><span class="comment">* 虚拟头节点设置为null,作为反转后链表的尾部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curNode = head;</span><br><span class="line">    <span class="keyword">let</span> preNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(curNode !==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tempNode = curNode.<span class="property">next</span>;</span><br><span class="line">        curNode.<span class="property">next</span> = preNode;</span><br><span class="line">        preNode = curNode;</span><br><span class="line">        curNode = tempNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preNode;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><ul>
<li>方法一：借助线性表，从而获取链表之间的顺序。借助数组，把链表节点存入数组中，注意这里其实存的是引用，所以改变next的指向，就可以获得重排后的链表</li>
<li>方法二：既然链表反向顺序我们不知道，那我们就反转链表。先找到链表中点，最后反转右半边链表，最后合并链表</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reorderList</span>(<span class="params"> head </span>) &#123;</span><br><span class="line">    <span class="comment">// 方法一：重排链表，由于无法确定链表的顺序，所以借助其它线性表。这里借助数组，把链表节点放在数组中，这里放在数组中，是浅拷贝，然后改变指针next的指向就可以</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> p = head;</span><br><span class="line">    <span class="keyword">if</span>(head === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(p);</span><br><span class="line">        p = p.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = res.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = res[i].<span class="property">next</span>;</span><br><span class="line">        res[i].<span class="property">next</span> = res[j];</span><br><span class="line">        res[j].<span class="property">next</span> = temp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    res[i].<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：既然链表不是有序的话，那我们可以反转右半边的链表，那么首先需要找到链表的中点</span></span><br><span class="line">    <span class="comment">//链表中点：可以使用快慢指针，慢指针一次走1步，快指针一次走两步。当快指针走到链表尾的时候，慢指针在重点，或者左端点</span></span><br><span class="line">     <span class="comment">//采用分割链表，反转链表，最后合并链表</span></span><br><span class="line">    <span class="keyword">let</span> slow = head, fast = head;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast.<span class="property">next</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span> ) &#123; <span class="comment">//注意这里有两个判断条件，fast存在并且fast.next存在</span></span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = slow.<span class="property">next</span>;</span><br><span class="line">    slow.<span class="property">next</span> = <span class="literal">null</span>;<span class="comment">//切断链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span>; <span class="comment">//反转链表</span></span><br><span class="line">    <span class="keyword">let</span> cur = mid;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p = pre, q = head; <span class="comment">//合并链表。合并链表搞清楚合并步骤的顺序，有些节点是需要事先记录下来的</span></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">let</span> tempQ = q.<span class="property">next</span>;</span><br><span class="line">        q.<span class="property">next</span> = p;</span><br><span class="line">        <span class="keyword">let</span> tempP = p.<span class="property">next</span>;</span><br><span class="line">        p.<span class="property">next</span> = tempQ;</span><br><span class="line">        q = tempQ;</span><br><span class="line">        p = tempP;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-两两交换链表中的节点"><a href="#4-两两交换链表中的节点" class="headerlink" title="4. 两两交换链表中的节点"></a>4. 两两交换链表中的节点</h3><ul>
<li>画图确定交换的顺序就可以</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">let</span> ppre = dummyNode, pre = head, cur = head.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur &amp;&amp; pre) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span> = pre;</span><br><span class="line">        ppre.<span class="property">next</span> = cur;</span><br><span class="line">        pre.<span class="property">next</span> = temp;</span><br><span class="line">        </span><br><span class="line">        ppre = pre;</span><br><span class="line">        pre = temp;</span><br><span class="line">        <span class="keyword">if</span>(temp) cur = temp.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">else</span> cur = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-删除链表倒数第n个节点"><a href="#5-删除链表倒数第n个节点" class="headerlink" title="5. 删除链表倒数第n个节点"></a>5. 删除链表倒数第n个节点</h3><pre><code>* 采用双指针的方法，一个slow，一个fast。fast比slow多走n步
</code></pre>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);<span class="comment">//设置虚拟头节点，防止删除的节点就是头节点这种情况</span></span><br><span class="line">    <span class="keyword">let</span> fast = head, slow = head,preNode = dummyNode;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        preNode = preNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode.<span class="property">next</span> = slow.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.<span class="property">next</span>;<span class="comment">//注意返回的结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6-链表相交"><a href="#6-链表相交" class="headerlink" title="6. 链表相交"></a>6. 链表相交</h3><ul>
<li>计算两个链表的长度之差</li>
</ul>
<h3 id="7-环形链表"><a href="#7-环形链表" class="headerlink" title="7. 环形链表"></a>7. 环形链表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形链表，定义slow和fast指针，slow指针每次移动一位，fast指针每次移动二位</span></span><br><span class="line"><span class="comment"> * 判断是否有环：slow和fast指针如果相遇的话</span></span><br><span class="line"><span class="comment"> * 找寻环的入口：相遇节点和head节点移动相同的位移，相遇时即为环入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> findStart = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> a = head;</span><br><span class="line">        <span class="keyword">let</span> b = node;</span><br><span class="line">        <span class="keyword">while</span>(a !== b) &#123;</span><br><span class="line">            a = a.<span class="property">next</span>;</span><br><span class="line">            b = b.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast.<span class="property">next</span>) fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">findStart</span>(slow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>链表散乱分布在内存中的某个地址上。</li>
<li>链表的增删改操作很容易进行，但是查询不容易。</li>
<li>对于链表的一些问题可使用虚拟头节点</li>
<li>在做反转链表等操作时，先弄清楚调整的顺序，再做题。对于一些需要改变的指针，可考虑采用临时变量存储下来</li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>用于<strong>快速判断一个元素是否出现在集合中</strong></li>
</ul>
<h3 id="1-有效的字母异位词"><a href="#1-有效的字母异位词" class="headerlink" title="1. 有效的字母异位词"></a>1. 有效的字母异位词</h3><ul>
<li><p>用数组作为哈希表，因为索引为26个字母，比较集中</p>
</li>
<li><p>首先为字符串s建立哈希表；然后遍历t，逐步减少s哈希表中的数字；最后检查s哈希表中所有字符出现字数是否都是0</p>
</li>
</ul>
<h3 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2. 两数之和"></a>2. 两数之和</h3><ul>
<li><p><strong>题目描述：</strong>找出目标和为<code>target</code>的整数并返回他们的下标</p>
</li>
<li><p><strong>思路</strong>：采用哈希来减少算法复杂度，<code>key</code>是数值，<code>value</code>是数值的索引。遍历一遍数组，向哈希表中存入数值，后续直接判断<code>target - value</code>是否存在于哈希表中即可</p>
</li>
<li><pre><code class="js">vat towSum = function(nums, target) &#123;
    let map = new Map();
    for(let i = 0; i &lt; nums.length; i++) &#123;
        let second = target - nums[i];
        if(map.has(second)) &#123;
            return [i, map.get(second)];
        &#125;else &#123;
            map.set(nums[i], i);
        &#125;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3. 字母异位词分组</span><br><span class="line"></span><br><span class="line">* **题目描述**：给定字符串数组，将字母异位词组合在一起。（字母异位词：对原字符串重新排列组合）</span><br><span class="line"></span><br><span class="line">* **思路**：</span><br><span class="line"></span><br><span class="line">  * 字母异位词有一个共同特性，排序后得到的字符串相同</span><br><span class="line">  * 使用哈希表解决，`key`就是排序后的字符串，`value`是一个数组</span><br><span class="line"></span><br><span class="line">* ```js</span><br><span class="line">  var groupAnagrams = function(strs) &#123;</span><br><span class="line">      let map = new Map();</span><br><span class="line">      for(let i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">          let arr = Array.from(strs[i]);</span><br><span class="line">          arr.sort();</span><br><span class="line">          let str  = arr.toSting();</span><br><span class="line">          let list = map.has(str) ? map.get(str) : new Array();</span><br><span class="line">          list.append(strs[i]);</span><br><span class="line">          map.set(str, list);</span><br><span class="line">      &#125;</span><br><span class="line">      return Array.from(map.values());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="4-最长连续序列"><a href="#4-最长连续序列" class="headerlink" title="4. 最长连续序列"></a>4. 最长连续序列</h3><ul>
<li><p><strong>题目描述</strong>：给定一个未排序的数组，给出数字连续的最长序列的长度</p>
</li>
<li><p><strong>思路</strong>：</p>
<ul>
<li><p>遍历一遍数组，只需判断<code>num - 1</code>是否在数组中，如果不在，则说明是一个连续序列的起始位置，则继续判断<code>num + 1</code>、<code>num + 2</code>是否在数组中。</p>
</li>
<li><p>考虑到数组中可能有重复元素，使用<code>set</code>对数组进行去重。</p>
</li>
<li><p>使用<code>for of</code>循环遍历<code>set</code>，<code>set</code>中的<code>has</code>方法的时间复杂度是<code>o(1)</code></p>
</li>
<li><pre><code class="js">var longestConsecutive = function(nums) &#123;
    let new_nums = new Set(nums);	// 去重处理
    let result = 0;
    for(const num of new_nums) &#123;
        if(!new_nums.has(num - 1)) &#123;
            let temp = num;
            let count = 0;
            while(new_nums.has(temp)) &#123;
                count++;
                temp++;
            &#125;
            result = Math.max(result, count);
        &#125;
    &#125;
    return result;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">## 字符串</span><br><span class="line"></span><br><span class="line">* 需要注意的是，**js中的字符串是不可变的。**如果想要对字符串赋值，必须生成新的字符串。</span><br><span class="line">* 这里采用**s.split(&quot;&quot;)**的方法，将字符串按照字符进行拆分，得到数组</span><br><span class="line">* 再使用**arr.join(&quot;&quot;)**的方法，将数组中的各元素连接起来，生成字符串</span><br><span class="line"></span><br><span class="line">### 1. 反转字符串</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var reverseStr = function(s, k) &#123;</span><br><span class="line">    var len = s.length;</span><br><span class="line">    let arr = s.split(&quot;&quot;);</span><br><span class="line">    for(let i = 0; i &lt; len; i += 2 * k ) &#123;  //循环中使用2 * k作为循环项</span><br><span class="line">        let l = i  - 1;</span><br><span class="line">        let r = i + k &gt; len ? len : i + k;  //r为i+ k</span><br><span class="line">        while(++l &lt; --r) &#123;</span><br><span class="line">            [arr[l], arr[r]] = [arr[r], arr[l]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.join(&quot;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">var reverse = function(str, left, right) &#123;</span><br><span class="line">    var arr = str.split(&quot;&quot;);</span><br><span class="line">    right = right - 1;</span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        var temp = arr[right];</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">        arr[left] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"> * 找规律，反转的区间是有规律的，从2*i*k到（2* i+1）*k-1</span><br><span class="line"> * 然后再反转不足k的部分</span><br><span class="line">  */</span><br><span class="line">var reverseStr = function(s, k) &#123;</span><br><span class="line">    let arr = s.split(&quot;&quot;);</span><br><span class="line">    let reverse = function(start, end) &#123;</span><br><span class="line">        let swap = function(left, right) &#123;</span><br><span class="line">            let temp = arr[right];</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">            arr[left] = temp; </span><br><span class="line">        &#125;</span><br><span class="line">        let left = start;</span><br><span class="line">        let right = end;</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            swap(left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    let i = 0;</span><br><span class="line">    for(; (2 * i + 1) * k - 1 &lt; s.length; i++) &#123;</span><br><span class="line">        reverse(2 * i * k, (2 * i +1) * k - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    if(s.length -1&gt; 2 * i * k) &#123;//反转不足k的部分</span><br><span class="line">        reverse(2 * i * k, s.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.join(&quot;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="2. 左旋转字符串"></a>2. 左旋转字符串</h3><ul>
<li>考虑o(1)的空间复杂度，<br>1. 先翻转前部分字符串<br>2. 再翻转后部分字符串<br>3. 最后整体翻转字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="keyword">function</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="comment">//方法一： 使用了额外的空间</span></span><br><span class="line">    <span class="comment">// var tempStr = s.substring(0, n);</span></span><br><span class="line">    <span class="comment">// var arr = Array.from(s);</span></span><br><span class="line">    <span class="comment">// var slow = 0;</span></span><br><span class="line">    <span class="comment">// var fast = n;</span></span><br><span class="line">    <span class="comment">// while(fast &lt; s.length) &#123;</span></span><br><span class="line">    <span class="comment">//     arr[slow++] = arr[fast++];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// var i = 0;</span></span><br><span class="line">    <span class="comment">// while(slow &lt; s.length)&#123;</span></span><br><span class="line">    <span class="comment">//     arr[slow++] = s[i++];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return arr.join(&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：在源字符串上进行操作</span></span><br><span class="line">    <span class="keyword">var</span> arr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="title function_">reverseWord</span>(arr, <span class="number">0</span>, n);		<span class="comment">//翻转前部分字符串</span></span><br><span class="line">    <span class="title function_">reverseWord</span>(arr, n, s.<span class="property">length</span>);		<span class="comment">//翻转后部分字符串</span></span><br><span class="line">    <span class="title function_">reverseWord</span>(arr, <span class="number">0</span>, s.<span class="property">length</span>);		<span class="comment">//翻转一整个字符串</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> reverseWord = <span class="keyword">function</span>(<span class="params">str, start, end</span>) &#123;	<span class="comment">//翻转字符串</span></span><br><span class="line">    <span class="keyword">var</span> left = start;</span><br><span class="line">    <span class="keyword">var</span> right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = str[right];</span><br><span class="line">        str[right] = str[left];</span><br><span class="line">        str[left] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-找出字符串中第一个匹配项的下标"><a href="#3-找出字符串中第一个匹配项的下标" class="headerlink" title="3. 找出字符串中第一个匹配项的下标"></a>3. 找出字符串中第一个匹配项的下标</h3><ul>
<li><p>字符串的匹配问题，KMP算法。最重要的是构建next数组（字符串的前缀和后缀）。根据next数组，来判断匹配过程中j的移动位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找字符串中子串的位置，采用KMP算法</span></span><br><span class="line"><span class="comment"> * KMP算法最终要的是构造next数组（找到模式串中每个字符的前缀和后缀）</span></span><br><span class="line"><span class="comment"> * 构造next数组：</span></span><br><span class="line"><span class="comment"> *  1. 定义i,j指针，i指针遍历模式串，j指针从0开始，j指针的位置就是next数组中的值</span></span><br><span class="line"><span class="comment"> *  2. 遍历i模式串时，如果needle[i]和needle[j]不相等的话，j移动到next[j - 1]的位置</span></span><br><span class="line"><span class="comment"> *  3. 如果needle[i] 和needle[j]相等的话，j++;</span></span><br><span class="line"><span class="comment"> *  4. 最后，把j的值赋给next[i]</span></span><br><span class="line"><span class="comment"> * 找索引</span></span><br><span class="line"><span class="comment"> *  1. 定义i，j指针，i指针遍历原串，j指针遍历模式串</span></span><br><span class="line"><span class="comment"> *  2. 遍历原串的时，如果haystack[i] 等于 needle[j] ，j++</span></span><br><span class="line"><span class="comment"> *  3. 如果不相等，则j = next[j - 1];</span></span><br><span class="line"><span class="comment"> *  4. 如果j等于needle的长度，则找到了匹配位置，返回结果即可</span></span><br><span class="line"><span class="comment"> *  5. 否则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span>(<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(needle.<span class="property">length</span> == <span class="number">0</span>) &#123;    <span class="comment">// 为空串，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建next数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getNext</span> = (<span class="params">needle</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> next = [];</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        next.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; needle.<span class="property">length</span>; i++) &#123;    <span class="comment">//  i遍历模式串</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;    <span class="comment">//  needle[i]和needle[j]不相等的时候，移动j的位置</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle[i] == needle[j]) &#123;    <span class="comment">// 相等的时候，j++</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next.<span class="title function_">push</span>(j);   <span class="comment">//j 的位置就是next数组的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> next = <span class="title function_">getNext</span>(needle);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.<span class="property">length</span>; i++) &#123;  <span class="comment">//i遍历原串，j遍历模式串</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;  <span class="comment">// 不相等取next数组值</span></span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(haystack[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == needle.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (i - needle.<span class="property">length</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 找不到，返回-1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-替换空格"><a href="#4-替换空格" class="headerlink" title="4. 替换空格"></a>4. 替换空格</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 不使用额外空间</span></span><br><span class="line"><span class="comment"> * 先扩充数组，然后双指针填充。由于js中数组是不定长的，所以arr数组可以直接通过设置length扩容</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span> + <span class="number">2</span> * count);<span class="comment">//arr数组扩容</span></span><br><span class="line">    <span class="keyword">let</span> left = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span>(s[left] === <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">            arr[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            arr[right--] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">            arr[right] = <span class="string">&quot;%&quot;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            arr[right] = s[left];</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="1-三数之和"><a href="#1-三数之和" class="headerlink" title="1. 三数之和"></a>1. 三数之和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先选定一个数，再判断另外两个数的组合情况。另外两个数的和必须是sum-第一个数</span></span><br><span class="line"><span class="comment"> * 这种判断两个数和是否等于另一个数的题，就是将数组排序，使用双指针，判断左右指针的和与target的关系</span></span><br><span class="line"><span class="comment"> * 由于答案中不能包含重复数组，什么时候会重复呢？比如第一个数重复了，那么答案一定有重复的，所以对第一个数去重</span></span><br><span class="line"><span class="comment"> * 对left去重的时候，需要考虑到去重的必须是left可能取到的值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">let</span> target = -nums[i];</span><br><span class="line">        <span class="keyword">let</span> left = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; (i + <span class="number">1</span>) &amp;&amp; nums[left] === nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                left++;<span class="comment">//注意这里的left大于i+1</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] + nums[right] === target) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([nums[i], nums[left], nums[right]]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-四数之和"><a href="#2-四数之和" class="headerlink" title="2. 四数之和"></a>2. 四数之和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选定两个数，遍历剩下的数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//对i去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span> - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; (i+<span class="number">1</span>) &amp;&amp;  nums[j] === nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//对j去重</span></span><br><span class="line">            <span class="keyword">let</span> left = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(left &gt; (j+<span class="number">1</span>) &amp;&amp; nums[left] === nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//对left去重</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum === target) &#123;</span><br><span class="line">                    result.<span class="title function_">push</span>([nums[i], nums[j], nums[left],nums[right]]);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-快乐数"><a href="#3-快乐数" class="headerlink" title="3. 快乐数"></a>3. 快乐数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 如果最后sum为1的话，那么这就是快乐数</span></span><br><span class="line"><span class="comment"> * 不能一直循环；判断是否为1呀？因为有的数不是快乐数，该怎么办？</span></span><br><span class="line"><span class="comment"> * 不是快乐数的话，由于它会无线循环，无限循环代表着sum会重复出现，只要sum重复出现了</span></span><br><span class="line"><span class="comment"> * 说明，这个计算会一直循环下去。</span></span><br><span class="line"><span class="comment"> * 判断之前有没有出现过sum, 判断一个集合中，某个数是否出现过</span></span><br><span class="line"><span class="comment"> * 使用set数据结构，可以判断是否出现一个元素是否出现在某个集合中</span></span><br><span class="line"><span class="comment"> * 判断快乐数的时候，重复计算每个数之和，把这部分抽成函数，参数是数，返回sum</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> getSum = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num) &#123;</span><br><span class="line">            sum += <span class="title class_">Math</span>.<span class="title function_">pow</span>(num % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">10</span>);<span class="comment">//第一个踩坑，取十位数的时候，需要向下取整</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;<span class="comment">//得到这个数的所有位置平方和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="title function_">getSum</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(result.<span class="title function_">has</span>(sum)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">add</span>(sum);</span><br><span class="line">            sum = <span class="title function_">getSum</span>(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1-匹配问题："><a href="#1-匹配问题：" class="headerlink" title="1. 匹配问题："></a>1. 匹配问题：</h3><ul>
<li>采用栈处理（成对匹配）</li>
</ul>
<h3 id="2-有效的括号"><a href="#2-有效的括号" class="headerlink" title="2. 有效的括号"></a>2. 有效的括号</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配问题考虑用栈</span></span><br><span class="line"><span class="comment"> * 判断括号是否匹配，采用栈的结构</span></span><br><span class="line"><span class="comment"> * 左括号就入栈</span></span><br><span class="line"><span class="comment"> * 右括号就出栈，并判断出栈元素是否匹配（借助map判断是否匹配）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack = [];</span><br><span class="line">    <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    map.<span class="title function_">set</span>(<span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="comment">//另一种写法</span></span><br><span class="line">    <span class="comment">// map = &#123;</span></span><br><span class="line">    <span class="comment">//     &quot;(&quot;: &quot;)&quot;,</span></span><br><span class="line">    <span class="comment">//     &quot;&#123;&quot;: &quot;&#125;&quot;,</span></span><br><span class="line">    <span class="comment">//     &quot;[&quot;: &quot;]&quot;,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(s[i])) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(s[i]);   <span class="comment">//改进的地方：右括号入栈，只需要判断是否相等即可</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> char = stack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="title function_">get</span>(char) !== s[i]) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.<span class="property">length</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="2-优先队列"><a href="#2-优先队列" class="headerlink" title="2. 优先队列"></a>2. 优先队列</h3><ul>
<li><p>普通队列：先进先出，元素在队尾追加，在队列头删除</p>
</li>
<li><p>优先队列：元素被赋予优先级，优先级高的最先删除，（最高级先出）。常常采用堆结构实现。</p>
</li>
<li><p><strong>降序采用小顶堆，升序采用大顶堆</strong></p>
</li>
</ul>
<h3 id="3-滑动窗口最大值-单调队列"><a href="#3-滑动窗口最大值-单调队列" class="headerlink" title="3. 滑动窗口最大值(单调队列)"></a>3. 滑动窗口最大值(单调队列)</h3><ul>
<li>采用单调队列的数据结构，维护滑动窗口内的最大值，队列前端的元素是最大值</li>
<li>单调队列操作：</li>
<li>push:当前元素值大于队列末端元素，弹出队列末端元素，直到队列为空，或者，当前元素小于末端元素</li>
<li>pop: 当前元素值等于队列前端元素，弹出队列前端元素。否则，不做操作</li>
<li>这种单调队列，就可以维持当前滑动窗口的最大值在队列前端</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 思路：维护滑动窗口中的最大值，不需要对窗口中的所有元素排序，只需要维护单调递减队列即可</span></span><br><span class="line"><span class="comment">  * 单调递减队列的push操作：如果当前元素小于等于队列入口元素，直接push</span></span><br><span class="line"><span class="comment">                            如果当前元素大于队列入口元素（说明队列入口元素不可能成为最大值了）,将队列入口元素弹出。直到小于等于队列入口元素的时候，才push</span></span><br><span class="line"><span class="comment">  * 单调递减队列的pop操作：如果窗口要丢弃的值，等于队列首的元素值，那么把队列首元素移除队列。否则，不做任何操作</span></span><br><span class="line"><span class="comment">  * 这样队列首的元素始终是该窗口内的最大值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MonoQueue</span> &#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(value &gt; <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>();<span class="comment">//大于队列入口元素，弹出队列入口元素</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">pop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(value === <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>]) &#123;<span class="comment">//等于队首元素，弹出队首元素</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> monoQueue = <span class="keyword">new</span> <span class="title class_">MonoQueue</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        monoQueue.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    result.<span class="title function_">push</span>(monoQueue.<span class="title function_">front</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span> - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        monoQueue.<span class="title function_">push</span>(nums[i+k-<span class="number">1</span>]);<span class="comment">//维护窗口</span></span><br><span class="line">        monoQueue.<span class="title function_">pop</span>(nums[i-<span class="number">1</span>]);</span><br><span class="line">        result.<span class="title function_">push</span>(monoQueue.<span class="title function_">front</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="4-前K个高频元素"><a href="#4-前K个高频元素" class="headerlink" title="4. 前K个高频元素"></a>4. 前K个高频元素</h3><ul>
<li>首先借助map，记录每个元素出现的次数</li>
<li>前k个高频元素，是降序，采用小顶堆。当堆内元素超过k个之后，弹出最小的元素，就可以保证剩下的是前k个高频元素</li>
<li>构造堆的过程：（堆可以使用数组来实现）<ul>
<li>push：加入堆末尾，不断比较children和parent，不断上移，满足parent小于左右孩子</li>
<li>pop：删除堆顶元素，把堆末尾元素放在堆顶，不断下沉，维护堆的结构</li>
</ul>
</li>
<li>js中没有堆结构，需自己构建堆。有一个queue数组，以及compareFn比较函数</li>
<li>注意：本题中堆内存放的是长度为2的数组，索引为0的位置，存放key，索引为1的位置存放value（出现次数）。所以比较函数，比较的是<code>a[1] - b[1] （索引为1）</code></li>
<li>堆就是一颗完全二叉树，保证父子节点的顺序关系</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 前k的问题，使用堆结构，小顶堆，堆顶是产生堆中最小的元素，</span></span><br><span class="line"><span class="comment">  * 维护一个最大长度为k的堆，当有新元素加入时，如果长度小于k,直接加入堆即可。</span></span><br><span class="line"><span class="comment">  * 如果长度大于等于k了，则先调整堆，弹出堆内最小的元素，再加入新元素，即可维护前k高的元素</span></span><br><span class="line"><span class="comment">  * 用map存储每一个数出现的频率</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * 调整堆：从最后一个非叶子节点开始调整，每个非叶子节点从上往下调整</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(nums[i], map.<span class="title function_">has</span>(nums[i]) ? map.<span class="title function_">get</span>(nums[i]) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> heap = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> swap = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = heap[t];</span><br><span class="line">        heap[t] = heap[s];</span><br><span class="line">        heap[s] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> adjust = <span class="keyword">function</span>(<span class="params">index</span>) &#123;<span class="comment">//调整以该节点为根的堆，从上往下调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">2</span>* index + <span class="number">1</span>; k &lt; heap.<span class="property">length</span>; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> min = heap[index][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">let</span> minIndex = index;</span><br><span class="line">            <span class="keyword">if</span>((k+<span class="number">1</span>) &lt; heap.<span class="property">length</span> &amp;&amp; heap[k+<span class="number">1</span>][<span class="number">1</span>] &lt; min) &#123;</span><br><span class="line">                min = heap[k+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                minIndex = k + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(heap[k][<span class="number">1</span>] &lt; min) &#123;</span><br><span class="line">                min = heap[k][<span class="number">1</span>];</span><br><span class="line">                minIndex = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex !== index) &#123;<span class="comment">//需要调整堆,for循环继续</span></span><br><span class="line">                <span class="title function_">swap</span>(minIndex, index);</span><br><span class="line">                index = k;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//不需要调整堆</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> adjustHeap = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//调整堆的结构,从最后一个非叶子节点开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(heap.<span class="property">length</span> / <span class="number">2</span>) -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="title function_">adjust</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> pair <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;<span class="comment">//pair[0]存储元素值，pair[1]存储出现的次数</span></span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="property">length</span> &lt; k) &#123;<span class="comment">//堆还没满，可以直接加在末尾，</span></span><br><span class="line">            heap.<span class="title function_">push</span>(pair);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//堆的长度为k了，已经满了，调整堆，弹出最小的元素,并压入新元素</span></span><br><span class="line">            <span class="title function_">adjustHeap</span>();</span><br><span class="line">            <span class="keyword">if</span>(heap[<span class="number">0</span>][<span class="number">1</span>] &lt; pair[<span class="number">1</span>]) &#123;</span><br><span class="line">                heap.<span class="title function_">shift</span>();</span><br><span class="line">                heap.<span class="title function_">push</span>(pair);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> heap.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item[<span class="number">0</span>])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>栈先进后出，队列后进先出</li>
<li>javascript中可以使用数组模拟栈，有push和pop函数</li>
<li>栈用于处理<strong>匹配问题</strong><ul>
<li>有效的括号：一对一对的匹配</li>
<li>字符串中所有相邻重复项：重复项就是一个匹配问题</li>
<li>逆波兰表达式（后缀表达式）：适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-前中后序遍历"><a href="#1-前中后序遍历" class="headerlink" title="1. 前中后序遍历"></a>1. 前中后序遍历</h3><ul>
<li>二叉树常用递归来解决，</li>
<li>递归写法：<ol>
<li>确定递归函数的参数和返回值</li>
<li>确定递归的终止条件</li>
<li>确定单层递归逻辑</li>
</ol>
</li>
</ul>
<h3 id="2-层序遍历"><a href="#2-层序遍历" class="headerlink" title="2. 层序遍历"></a>2. 层序遍历</h3><ul>
<li>使用队列来实现层次遍历，每弹出一个元素，就push进该元素的孩子</li>
<li>注意点：由于不知道一层有几个元素，所以采用变量len记录一下每次元素中的个数就可以</li>
<li>首先需要判断根节点是否为空</li>
<li>遍历结束的条件是：队列为空</li>
<li>两层循环，外层循环加入每一层的结果 循环条件queue.length!&#x3D;0</li>
<li>内层循环，加入某一层的结果，循环条件len!&#x3D;0</li>
</ul>
<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><ul>
<li>轴对称</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 比较的是左右孩子，所以递归函数的参数是两个left和right</span></span><br><span class="line"><span class="comment">  * 一直递归，当左孩子和右孩子都保证是抽对称的时候，才返回对称</span></span><br><span class="line"><span class="comment">  * 递归终止条件：当左右孩子都为空的时候，返回true</span></span><br><span class="line"><span class="comment">                  其它情况返回false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">let</span> mySymmetric = <span class="keyword">function</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//注意这个返回true的情况</span></span><br><span class="line">    <span class="keyword">if</span>(!left &amp;&amp; right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(left.<span class="property">val</span> !== right.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mySymmetric</span>(left.<span class="property">right</span>, right.<span class="property">left</span>) &amp;&amp; <span class="title function_">mySymmetric</span>(left.<span class="property">left</span>, right.<span class="property">right</span>);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mySymmetric</span>(root.<span class="property">left</span>, root.<span class="property">right</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>* </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 递归函数参数是节点，返回值是参数是高度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">let</span> height = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> leftHeight = <span class="title function_">height</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">let</span> rightHeight = <span class="title function_">height</span>(node.<span class="property">right</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;<span class="comment">//返回左右节点的最大值，如果节点不存在，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>( <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title function_">height</span>(root.<span class="property">left</span>) - <span class="title function_">height</span>(root.<span class="property">right</span>)) &gt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//判断当前节点的左右孩子高度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isBalanced</span>(root.<span class="property">left</span>) &amp;&amp;  <span class="title function_">isBalanced</span>(root.<span class="property">right</span>);<span class="comment">//递归判断左孩子和右孩子</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 找路径的过程中，没有返回值，而原函数有返回值，所以再写一个函数</span></span><br><span class="line"><span class="comment">  * 递归函数终止条件，当node是叶子节点的时候，加入路径</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> path = [];</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> backTracing = <span class="keyword">function</span>(<span class="params">node</span>) &#123;<span class="comment">//参数是节点，没有返回值</span></span><br><span class="line">        path.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>([...path].<span class="title function_">join</span>(<span class="string">&quot;-&gt;&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">left</span>) &#123;</span><br><span class="line">            <span class="title function_">backTracing</span>(node.<span class="property">left</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="title function_">backTracing</span>(node.<span class="property">right</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 求左叶子之和，遍历的时候需要访问右节点，但是右节点的右叶子不能算入，所以叶子不是唯一的判断标准，必须知道是左节点得到的叶子，还是右节点得到的叶子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">let</span> cacluLeft = <span class="keyword">function</span>(<span class="params">node, isLeft</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span> &amp;&amp; isLeft) &#123;</span><br><span class="line">            sum+= node.<span class="property">val</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="property">left</span> &amp;&amp; <span class="title function_">cacluLeft</span>(node.<span class="property">left</span>, <span class="literal">true</span>);</span><br><span class="line">        node.<span class="property">right</span> &amp;&amp; <span class="title function_">cacluLeft</span>(node.<span class="property">right</span>, <span class="literal">false</span>);<span class="comment">//中序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">cacluLeft</span>(root, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 找到最大深度时的值，前序遍历，最大深度后，就更新值，这样后面的不会影响前面的，因为在同一层</span></span><br><span class="line"><span class="comment">  * 递归参数：节点，当前的深度deep</span></span><br><span class="line"><span class="comment">  * 递归返回值：只是记录最大深度的节点值，所以没有返回值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxDeep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> recur = <span class="keyword">function</span>(<span class="params">node, curDeep</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        curDeep++;</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span>) &#123;<span class="comment">//碰到叶子节点了</span></span><br><span class="line">            <span class="keyword">if</span>(curDeep&gt; maxDeep) &#123;<span class="comment">//判断是否深度变大了</span></span><br><span class="line">                maxDeep = curDeep;</span><br><span class="line">                result = node.<span class="property">val</span>;<span class="comment">//深度变大就更新最大深度以及结果的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">recur</span>(node.<span class="property">left</span>, curDeep);</span><br><span class="line">        <span class="title function_">recur</span>(node.<span class="property">right</span>, curDeep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">recur</span>(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 递归参数：当前节点，目标和，</span></span><br><span class="line"><span class="comment">  * 返回值：找到路径等于targer的就返回true，否则返回false</span></span><br><span class="line"><span class="comment">  * 递归终止条件：遇到叶子节点，判断路径和是否等于target,如果等于就返回true，不等于的话，返回false。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">let</span> find = <span class="keyword">function</span>(<span class="params">node, targetSum,sum</span>) &#123;</span><br><span class="line">    sum += node.<span class="property">val</span>;</span><br><span class="line">    <span class="keyword">if</span>(!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum === targetSum ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">left</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">find</span>(node.<span class="property">left</span>, targetSum, sum);</span><br><span class="line">        <span class="comment">//sum-= node.left.val;注意这里的sum没有减去，因为sum作为参数传递了</span></span><br><span class="line">        <span class="keyword">if</span>(result) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">right</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="title function_">find</span>(node.<span class="property">right</span>, targetSum, sum);</span><br><span class="line">        <span class="comment">//sum-= node.right.val;</span></span><br><span class="line">        <span class="keyword">if</span>(result) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">find</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h3 id="3-递归的注意事项"><a href="#3-递归的注意事项" class="headerlink" title="3. 递归的注意事项"></a>3. 递归的注意事项</h3><ol>
<li><p><strong>确定递归函数的返回值：</strong></p>
<ol>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</li>
</ol>
</li>
<li><p><strong>注意回溯</strong>，递归和回溯是一对一的，有递归就有回溯</p>
</li>
<li><p>详见112和113<strong>求路径总和的题</strong></p>
<ol>
<li><p>112中满足target之后，就返回。返回的true&#x2F;false,不需要遍历整棵树。注意需要处理递归的返回值</p>
</li>
<li><pre><code class="javascript">var hasPathSum = function(root, targetSum) &#123;
    var curSum = 0;
    var calcuSum = function(node) &#123;
        curSum += node.val;
        if(!node.left &amp;&amp; !node.right) &#123;
            if(curSum == targetSum) &#123;
                return true;
            &#125;else &#123;
                return false; 
            &#125;
            
        &#125;
        if(node.left) &#123;
            if(calcuSum(node.left)) return true;    //返回true
            curSum -= node.left.val;    //注意回溯
        &#125;
        if(node.right) &#123;
            if(calcuSum(node.right)) return true;
            curSum -= node.right.val;
        &#125;
        return false;
    &#125;
    if(!root) return false;
    return calcuSum(root);

&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 113中需要遍历整棵树。注意这里**js中数组的深拷贝**</span><br><span class="line"></span><br><span class="line">4. ```javascript</span><br><span class="line">   var pathSum = function(root, targetSum) &#123;   //该方法可通过</span><br><span class="line">       var result = new Array().map(() =&gt; new Array());</span><br><span class="line">       var queue = [];</span><br><span class="line">       var getPath = function(node, curSum, queue) &#123;     </span><br><span class="line">           if(!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">               if(curSum == targetSum) &#123;</span><br><span class="line">                   result.push([...queue]);    //注意点，要深拷贝，不可以写res.push(queue)</span><br><span class="line">               &#125;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           if(node.left) &#123;</span><br><span class="line">               curSum += node.left.val;</span><br><span class="line">               queue.push(node.left.val);</span><br><span class="line">               getPath(node.left, curSum, queue);</span><br><span class="line">               curSum -= node.left.val;	//回溯</span><br><span class="line">               queue.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           if(node.right) &#123;</span><br><span class="line">               curSum += node.right.val;</span><br><span class="line">               queue.push(node.right.val);</span><br><span class="line">               getPath(node.right, curSum, queue);</span><br><span class="line">               curSum -= node.right.val;</span><br><span class="line">               queue.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       if(!root) return null;</span><br><span class="line">       queue.push(root.val);</span><br><span class="line">       getPath(root, root.val, queue);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="4-构造二叉树"><a href="#4-构造二叉树" class="headerlink" title="4. 构造二叉树"></a>4. 构造二叉树</h3><ul>
<li><p>中序遍历+后序遍历构造二叉树；前序遍历+中序遍历构造二叉树</p>
<ul>
<li>采用递归的方法，</li>
<li>注意用数组构造二叉树的题目，<strong>每次分隔尽量不要定义新的数组，</strong>而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。</li>
</ul>
</li>
<li><p>中序遍历和后序遍历构造数组</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/***</span></span><br><span class="line"><span class="comment">  * 有递归的思想在，每次都是拿到中序遍历数组和后序遍历数组，然后两个数组一起构造</span></span><br><span class="line"><span class="comment">  * 后序遍历的数组的最后一个元素是当前的根节点，根节点左边是中序遍历在该根节点前面的元素</span></span><br><span class="line"><span class="comment">  * 根节点右边是中序数组中在该节点后面的元素</span></span><br><span class="line"><span class="comment">  * 递归函数的参数一个是中序数组，一个是后序数组，(xxx不对)</span></span><br><span class="line"><span class="comment">  * 返回值是中序数组和后数组构成的根节点</span></span><br><span class="line"><span class="comment">  * 终止条件中序后序数组为0</span></span><br><span class="line"><span class="comment">  * 一直切割数组不太好，空间复杂度高，所以递归参数应当是start和end</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="keyword">function</span>(<span class="params">inorder, postorder</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> recur = <span class="keyword">function</span>(<span class="params">leftStart, leftEnd, rightStart, rightEnd</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(leftEnd &lt; leftStart) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[rightEnd]);</span><br><span class="line">        <span class="keyword">let</span> rootIndex = inorder.<span class="title function_">indexOf</span>(node.<span class="property">val</span>);</span><br><span class="line">        <span class="keyword">let</span> count = rootIndex - leftStart;</span><br><span class="line">        node.<span class="property">left</span> = <span class="title function_">recur</span>(leftStart, rootIndex - <span class="number">1</span>, rightStart, rightStart + count -<span class="number">1</span>);</span><br><span class="line">        node.<span class="property">right</span> = <span class="title function_">recur</span>(rootIndex + <span class="number">1</span>, leftEnd,rightStart+count, rightEnd -<span class="number">1</span> );</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">recur</span>(<span class="number">0</span>, inorder.<span class="property">length</span> -<span class="number">1</span>, <span class="number">0</span>, postorder.<span class="property">length</span> - <span class="number">1</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5-二叉搜索树"><a href="#5-二叉搜索树" class="headerlink" title="5. 二叉搜索树"></a>5. 二叉搜索树</h3><ul>
<li>二叉搜索树的有序性</li>
<li>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个<strong>有序数组上</strong>求最值，求差值，这样就简单多了</li>
</ul>
<h4 id="1-验证二叉搜索树"><a href="#1-验证二叉搜索树" class="headerlink" title="1. 验证二叉搜索树"></a>1. 验证二叉搜索树</h4><ol>
<li><p>采用中序遍历，将二叉树的节点值放在数组中</p>
</li>
<li><p>中序递归遍历，判断root.val和maxValue的大小。递归函数返回true&#x2F;false.同样需要<strong>保证左子树和右子树都返回true</strong>.。(<strong>很巧妙的办法)</strong></p>
</li>
<li><p>递归遍历，判断范围（自己想的办法）</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个题：需要左子树和右子树都满足条件才可以。所以返回的需要leftRes&amp;&amp;rightRes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//方法一：使用递归，限定节点值得范围</span></span><br><span class="line"><span class="keyword">var</span> isChildrenValid = <span class="keyword">function</span>(<span class="params">root, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> leftRes = <span class="literal">true</span>, rightRes = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">left</span>.<span class="property">val</span> &lt; root.<span class="property">val</span> &amp;&amp; root.<span class="property">left</span>.<span class="property">val</span> &gt; left) &#123;</span><br><span class="line">            leftRes =  <span class="title function_">isChildrenValid</span>(root.<span class="property">left</span>, left, root.<span class="property">val</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">right</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">right</span>.<span class="property">val</span> &gt; root.<span class="property">val</span> &amp;&amp; root.<span class="property">right</span>.<span class="property">val</span> &lt; right) &#123;</span><br><span class="line">            rightRes = <span class="title function_">isChildrenValid</span>(root.<span class="property">right</span>, root.<span class="property">val</span>, right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftRes &amp;&amp; rightRes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isChildrenValid</span>(root, -<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>, <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法二：中序遍历得到二叉树的数组，判断数组是否有序（注意不能有重复元素）</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">buildArr</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="title function_">buildArr</span>(root.<span class="property">left</span>);</span><br><span class="line">            arr.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">            <span class="title function_">buildArr</span>(root.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">buildArr</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法三：对二叉树进行中序遍历，记录maxval，如果rootval小于等于maxval就返回false</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归函数返回true/false.同样需要保证左子树和右子树都返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> maxVal = -<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line">    <span class="keyword">var</span> inorder = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">var</span> left = <span class="title function_">inorder</span>(node.<span class="property">left</span>);<span class="comment">//递归函数有返回值，所以需要有接盘的东西</span></span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">val</span> &lt;= maxVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            maxVal = node.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> right = <span class="title function_">inorder</span>(node.<span class="property">right</span>);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">inorder</span>(root);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-二叉搜索树中的最小绝对差"><a href="#2-二叉搜索树中的最小绝对差" class="headerlink" title="2. 二叉搜索树中的最小绝对差"></a>2. 二叉搜索树中的最小绝对差</h4><ol>
<li><p>利用<strong>中序遍历</strong>，将二叉搜索树变成<strong>有序数组</strong>，在有序数组上进行排序</p>
</li>
<li><p>中序遍历的过程中可以记录前一个节点（<strong>重点</strong>）</p>
</li>
<li><pre><code class="javascript">/**
 * 方法二：在递归的过程中，记录前一个节点
 */
var getMinimumDifference = function(root) &#123;
    let res = Infinity
    let preNode = null	//首先置空
    // 中序遍历
    const inorder = (node) =&gt; &#123;
        if(!node) return
        inorder(node.left)
        // 更新res
        if(preNode) res = Math.min(res, node.val - preNode.val)
        // 记录前一个节点         
        preNode = node
        inorder(node.right)
    &#125;
    inorder(root)
    return res
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3. 二叉搜索数的众数</span><br><span class="line"></span><br><span class="line">* 不使用额外的空间，中序遍历二叉树，记录每个数出现的次数，</span><br><span class="line"></span><br><span class="line"> * 如果curCount大于maxCount，更新maxCount，并把结果数组置空</span><br><span class="line"></span><br><span class="line"> * 如果curCount==maxCount, 将当前值加入结果数组中</span><br><span class="line"></span><br><span class="line"> * 如果curCount &lt; maxCount，不用理会</span><br><span class="line"></span><br><span class="line"> * （但是自己的写法仍然用到多余的空间，valueList）</span><br><span class="line"></span><br><span class="line">* ```javascript</span><br><span class="line">  //方法二：不用valueList</span><br><span class="line">  var findMode = function(root) &#123;</span><br><span class="line">      var result = [];</span><br><span class="line">      var maxCount = -Infinity;</span><br><span class="line">      var curCount = -Infinity;</span><br><span class="line">      var pre = null;</span><br><span class="line">      const inorder = function(node) &#123;</span><br><span class="line">          if(!node) return;</span><br><span class="line">          inorder(node.left);</span><br><span class="line">          if(pre == null) &#123;</span><br><span class="line">              result.push(node.val);</span><br><span class="line">              maxCount = 1;</span><br><span class="line">              curCount = 1;</span><br><span class="line">              pre = node;</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              if(node.val == pre.val) &#123;</span><br><span class="line">                  curCount++; //相等，则couCount++</span><br><span class="line">              &#125;else &#123;</span><br><span class="line">                  curCount = 1;   //否则，置1</span><br><span class="line">              &#125;</span><br><span class="line">              if(curCount &gt; maxCount) &#123;   //判断curCount和maxCount的大小</span><br><span class="line">                  result.length = 0;  //js数组置空的方法</span><br><span class="line">                  result.push(node.val);</span><br><span class="line">                  maxCount = curCount;</span><br><span class="line">              &#125;else if(curCount == maxCount) &#123;</span><br><span class="line">                  result.push(node.val);</span><br><span class="line">              &#125;       </span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">          pre = node;</span><br><span class="line">          inorder(node.right);</span><br><span class="line">      &#125;</span><br><span class="line">      inorder(root);</span><br><span class="line">      return result;</span><br><span class="line">  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>* </p>
<h3 id="6-最近公共祖先"><a href="#6-最近公共祖先" class="headerlink" title="6. 最近公共祖先"></a>6. 最近公共祖先</h3><p>思路：找两个节点的最近的公共祖先，考虑找出每个节点的祖先，然后比较最后一个相等的节点即为最近公共祖先（需要找出每个节点的路径）</p>
<ul>
<li><p>递归的过程中，<strong>需要回溯</strong></p>
</li>
<li><p>怎样回溯：<strong>递归左子树&#x2F;右子树，需得到递归返回结果，</strong></p>
<ul>
<li>如果左子树中没有找到相应的节点，则需要返回弹出路径pop操作。</li>
<li>如果找到了，则返回true,递归结束。</li>
</ul>
</li>
<li><p>递归：</p>
<ol>
<li><p>参数: 节点root,节点的路径path，以及要找的节点值</p>
</li>
<li><p>返回值：不需要遍历整棵树，找到结果就返回，用true&#x2F;false</p>
</li>
<li><p>逻辑：push当前节点的值；递归左右子树，找到则返回true,否则回溯</p>
</li>
</ol>
</li>
<li><pre><code class="javascript">var lowestCommonAncestor = function(root, p, q) &#123;
    //先找到p的路径
    var pPath = [];
    var qPath = [];
    
    const findNode = function(node, path, val) &#123;
        path.push(node);
        if(node.val == val) &#123;
            return true;
        &#125;
        if(node.left) &#123;
            if(findNode(node.left, path,val)) return true;
            else path.pop();    //回溯的体现
        &#125;
        if(node.right) &#123;
            if(findNode(node.right, path,val)) return true;
            else path.pop();    //回溯的体现
        &#125;
        
        return false;
    &#125;
    findNode(root, pPath, p.val);
    findNode(root, qPath, q.val);
    var result = [];
    for(var i = 0; i&lt; pPath.length &amp;&amp; i &lt; qPath.length; i++) &#123;
        if(pPath[i] == qPath[i]) &#123;
            result.push(pPath[i]) ;
        &#125;
    &#125;
    return result.pop()
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">或者采用后序遍历，就可以实现从下往上进行</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">    // 使用递归的方法</span><br><span class="line">    // 需要从下到上，所以使用后序遍历</span><br><span class="line">    // 1. 确定递归的函数</span><br><span class="line">    const travelTree = function(root,p,q) &#123;</span><br><span class="line">        // 2. 确定递归终止条件</span><br><span class="line">        if(root === null || root === p||root === q) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. 确定递归单层逻辑</span><br><span class="line">        let left = travelTree(root.left,p,q);</span><br><span class="line">        let right = travelTree(root.right,p,q);</span><br><span class="line">        if(left !== null&amp;&amp;right !== null) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left ===null) &#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">   return  travelTree(root,p,q);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> /***</span><br><span class="line">  * 找到一个节点，该节点的左子树有p,右子树有q,那么就是公共祖先</span><br><span class="line">  * 递归参数：节点，返回值，返回找到的节点</span><br><span class="line">  * 好奇怪，这个题</span><br><span class="line">  */</span><br><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">    if(!root) return null;</span><br><span class="line">    if(root == q || root == p) return root;</span><br><span class="line">    let left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    let right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    if(left &amp;&amp; right) return root;</span><br><span class="line">    else if(left &amp;&amp; !right) return left;</span><br><span class="line">    else  return right;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>二叉搜索树的最近公共祖先：从上往下搜索，只需判断节点的范围即可</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索树的性质，从上往下遍历即可</span></span><br><span class="line"><span class="comment"> * 当遇到处于p和q之间的节点时，即为最近公共祖先</span></span><br><span class="line"><span class="comment"> /**</span></span><br><span class="line"><span class="comment"> * 二叉搜索树的有序性，当遍历的节点的node的值处于p和q之间的时候，node就是公共祖先</span></span><br><span class="line"><span class="comment"> * 递归参数node,返回值，node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> findNode = <span class="keyword">function</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &lt; q.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &gt; q.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">findNode</span>(root.<span class="property">left</span>, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.<span class="property">val</span> &lt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &lt; q.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">findNode</span>(root.<span class="property">right</span>, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    <span class="comment">//否则返回自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findNode</span>(root, p, q);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树种的插入操作"><a href="#二叉搜索树种的插入操作" class="headerlink" title="二叉搜索树种的插入操作"></a>二叉搜索树种的插入操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不断的和根节点进行比较，递归参数node,返回值节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="keyword">function</span>(<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt; val) &#123;<span class="comment">//注意这里递归返回值的应用</span></span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">right</span>, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">left</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="7-删除二叉搜索树中的节点450"><a href="#7-删除二叉搜索树中的节点450" class="headerlink" title="7. 删除二叉搜索树中的节点450"></a>7. 删除二叉搜索树中的节点450</h3><ul>
<li><p>代码随想录的做法：</p>
</li>
<li><p>首先递归寻找该节点，如果找不到，遍历到空节点的时候，直接返回</p>
</li>
<li><p>如果找到了删除的节点node：</p>
<ol>
<li><p>node为叶子节点，直接删除节点，返回NULL作为根节点（注意这里的删除节点的方法，借助了递归的返回值，递归返回null就可以达到删除节点目的， 而自己的想法，在递归函数中将节点置空，这样就更改了节点的引用值，是无效的）</p>
</li>
<li><p>node无右孩子，直接返回node的左孩子，相当于左孩子向上提升</p>
</li>
<li><p>node无左孩子，直接返回node的右孩子，</p>
</li>
<li><p>node左右孩子都有，将node左孩子放在node右孩子的最左边节点的左孩子处，返回删除节点的右孩子（或者找到node右孩子最左边的节点，将它的值赋给node，然后以node的右孩子为根节点，删除最左边的节点）</p>
</li>
</ol>
</li>
<li><p>注意点：采用递归返回值，找到node后，返回删除后的根节点，这样完成置空操作，考虑到引用类型值传递，在递归函数中置空，是无效的，因为置空相当于改变了指向，对原来的节点没有任何改变</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(key &lt; root.<span class="property">val</span> ) &#123;</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">deleteNode</span>(root.<span class="property">left</span>, key);</span><br><span class="line">        <span class="keyword">return</span> root;	<span class="comment">//返回root</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root.<span class="property">val</span>) &#123;</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, key);</span><br><span class="line">        <span class="keyword">return</span> root;	<span class="comment">//返回root</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">left</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">right</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = <span class="title function_">findLeftChild</span>(root.<span class="property">right</span>);</span><br><span class="line">            root.<span class="property">val</span> = temp.<span class="property">val</span>;</span><br><span class="line">            root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, temp.<span class="property">val</span>);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归参数：节点node,返回值根节点。</span></span><br><span class="line"><span class="comment"> * 找到key后，取这个树中最大值的节点返回,返回右边节点，因为是搜索树，并把左边节点放在右边的最左孩子下</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &gt; key) root.<span class="property">left</span> = <span class="title function_">deleteNode</span>(root.<span class="property">left</span>, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.<span class="property">val</span> &lt; key) root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">right</span>) <span class="keyword">return</span> root.<span class="property">left</span>;</span><br><span class="line">        <span class="keyword">let</span> temp = root.<span class="property">right</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp.<span class="property">left</span>) &#123;</span><br><span class="line">            temp = temp.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="property">left</span> = root.<span class="property">left</span>;</span><br><span class="line">        <span class="keyword">return</span> root.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-修剪二叉搜索树"><a href="#8-修剪二叉搜索树" class="headerlink" title="8. 修剪二叉搜索树"></a>8. 修剪二叉搜索树</h3><ul>
<li><p>修剪二叉搜索树，使其节点处于L到R之中（修剪得过程中需要改动树的结构，删除节点，通过递归返回值可以删除节点）</p>
</li>
<li><p>递归方法，左右子树修剪完了之后返回根节点</p>
</li>
<li><p>但是如例子中的321中的0这种情况，0是需要删除的，可以通过递归返回根节点，把2作为3的左子树这种方法删除节点</p>
</li>
<li><p>递归的终止条件：当root为null时，返回空指针。</p>
</li>
<li><p>递归单层逻辑：</p>
</li>
<li><ul>
<li>如果root-val &lt; low的话，递归root的右子树，并返回右子树的递归结果</li>
</ul>
</li>
<li><ul>
<li>如果root-val &gt; hight的话，递归root的左子树，并返回左子树的递归结果</li>
</ul>
</li>
<li><ul>
<li>左右子树的接盘操作。root-left &#x3D; 递归左子树的结果</li>
</ul>
</li>
<li><ul>
<li><pre><code>              root-right = 递归右子树的结果
</code></pre>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trimBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt; low) <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">right</span>, low, high);	<span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &gt; high) <span class="keyword">return</span> <span class="title function_">trimBST</span>(root.<span class="property">left</span>, low, high);	</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">trimBST</span>(root.<span class="property">left</span>, low, high);		<span class="comment">//接盘逻辑</span></span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">trimBST</span>(root.<span class="property">right</span>, low, high);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归参数：节点node</span></span><br><span class="line"><span class="comment"> * 递归返回值: 调整后的新的根节点</span></span><br><span class="line"><span class="comment"> * 从下往上递归，采用后序遍历</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> trimBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root ) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    root.<span class="property">left</span> = <span class="title function_">trimBST</span>(root.<span class="property">left</span>, low, high);</span><br><span class="line">    root.<span class="property">right</span> = <span class="title function_">trimBST</span>(root.<span class="property">right</span>, low, high);<span class="comment">//更新左右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">val</span> &lt; low || root.<span class="property">val</span> &gt; high) &#123;<span class="comment">//修剪得操作</span></span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root.<span class="property">left</span> &amp;&amp; root.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">right</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root.<span class="property">right</span> &amp;&amp; root.<span class="property">left</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">left</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = root.<span class="property">right</span>;</span><br><span class="line">            <span class="keyword">while</span>(temp.<span class="property">left</span>) &#123;</span><br><span class="line">                temp = temp.<span class="property">left</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.<span class="property">left</span> = root.<span class="property">left</span>;</span><br><span class="line">            <span class="keyword">return</span> root.<span class="property">right</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-有序数组转换成二叉树"><a href="#9-有序数组转换成二叉树" class="headerlink" title="9. 有序数组转换成二叉树"></a>9. 有序数组转换成二叉树</h3><ul>
<li><p>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</p>
</li>
<li><pre><code class="javascript">var createBST = function(nums, start, end) &#123;
    if(start &gt; end) return null;
    var mid = Math.floor( (end + start)/2);
    var node = new TreeNode(nums[mid]);//建立中间节点
    node.left = createBST(nums, start, mid - 1);//左区间
    node.right = createBST(nums, mid + 1, end);//右区间
    return node;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 10. 二叉搜索树转成累加树</span><br><span class="line"></span><br><span class="line">* 使用反中序遍历，使用pre变量记录累加值</span><br><span class="line"></span><br><span class="line">* ```javascript</span><br><span class="line">  caclu(node.right);</span><br><span class="line">  node.val = node.val + pre;  //更改节点的值</span><br><span class="line">  pre= node.val;</span><br><span class="line">  caclu(node.left);</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 递归：从右到左，右中左，</span><br><span class="line">   * 递归参数：节点</span><br><span class="line">   * 返回值：累加值.这里不需要返回值？？</span><br><span class="line">    */</span><br><span class="line">  var convertBST = function(root) &#123;</span><br><span class="line">      let pre = 0;</span><br><span class="line">      let add = function(node) &#123;</span><br><span class="line">          if(!node) return 0;</span><br><span class="line">          add(node.right);</span><br><span class="line">          node.val = node.val + pre;</span><br><span class="line">          pre = node.val;</span><br><span class="line">          add(node.left);</span><br><span class="line">      &#125;</span><br><span class="line">      add(root);</span><br><span class="line">      return root;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="11-恢复二叉树"><a href="#11-恢复二叉树" class="headerlink" title="11.恢复二叉树"></a>11.恢复二叉树</h2><p>* </p>
<ul>
<li><pre><code class="js">var recoverTree = function(root) &#123;
    //方法一：找规律，交换后的二叉搜索树的中序遍历得到的数组的顺序发生了改变。
    //分为两种情况，第一种是有两个地方顺序不对，那么最后，交换两头的就可以。第二种情况是只有一处顺序不对，那么只需要交换这两个数就可以
    // let arr = [];
    // let inorder = function(node) &#123;
    //     if(!node) return;
    //     inorder(node.left);
    //     arr.push(node.val);
    //     inorder(node.right);
    // &#125;
    // inorder(root);
    // let leftIndex = -1, rightIndex = -1;
    // for(let i = 1; i &lt; arr.length; i++) &#123;
    //     if(arr[i] &lt; arr[i-1]) &#123;
    //         if(rightIndex === -1)  leftIndex = i-1
    //         rightIndex = i;
    //     &#125; 
    // &#125;
    // let leftValue = arr[leftIndex], rightValue = arr[rightIndex];
    // let count  = 0;
    // let swap = function(node) &#123;
    //     if(count === 2) return;
    //     if(!node) return;
    //     swap(node.left);
    //     if(node.val === leftValue) &#123;
    //         node.val = rightValue;
    //         count++;
    //     &#125;else if(node.val === rightValue) &#123;
    //         node.val = leftValue;
    //         count++
    //     &#125;
    //     swap(node.right);
    // &#125;
    // swap(root);


    //方法二：在中序遍历的过程中，可以发现顺序不对的节点，记录下顺序不对的节点，当第一次遇到顺序不对的节点的时候，可以更新x，其它时候不更新。这样交换两个节点，就不需要使用额外的空间
    let xNode = null, yNode = null;
    let pre = null;
    let inorder = function(node) &#123;
        if(!node) return;
        inorder(node.left);
        if(pre &amp;&amp; node.val &lt;= pre.val) &#123;
            if(!xNode) xNode = pre;//注意更新xNode的情况
            yNode = node;
        &#125;
        pre = node;
        inorder(node.right);
    &#125;
    inorder(root);

        let temp = xNode.val;
        xNode.val = yNode.val;
        yNode.val = temp;
    
    
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line"></span><br><span class="line">1. 删除二叉树的节点、增加二叉树的节点，都可以通过递归返回值来解决</span><br><span class="line"></span><br><span class="line">## 回溯法</span><br><span class="line"></span><br><span class="line">* 回溯就是为了解决嵌套for循环的</span><br><span class="line">* 三部曲：递归参数、终止条件，单层搜索过程，</span><br><span class="line"></span><br><span class="line">### 组合：</span><br><span class="line"></span><br><span class="line">* **回溯+ 递归。需要注意当candidate中包含重复元素的话，就要使用used数组进行剪枝**</span><br><span class="line"></span><br><span class="line">### 1. 组合</span><br><span class="line"></span><br><span class="line">* 找到范围 `[1, n]` 中所有可能的 `k` 个数的组合。</span><br><span class="line"></span><br><span class="line">* 回溯法</span><br><span class="line"></span><br><span class="line">  * 确定终止条件，当path中的长度达到k时，不再递归</span><br><span class="line">  * for循环，需要设置startIndex，防止结果有重复项比如12和21</span><br><span class="line">  * 递归，和for循环竟然一样，借助startIndex即可</span><br><span class="line"></span><br><span class="line">* 优化的点：剪枝，i &lt;= n - (k - path.length) + 1</span><br><span class="line"></span><br><span class="line">* &lt;img src=&quot;./img/组合回溯.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* ```javascript</span><br><span class="line">  var combine = function(n, k) &#123;</span><br><span class="line">      var result = Array.from(new Array(), () =&gt; new Array());</span><br><span class="line">      var path = new Array();</span><br><span class="line">      var backTracing = function(n, k, startIndex) &#123;</span><br><span class="line">          if(path.length == k) &#123;  //终止条件</span><br><span class="line">              result.push([...path]); //数组要深拷贝，不可以使用result.push(path);</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          for(var i = startIndex; i &lt;= n - (k - path.length) + 1 ; i++) &#123;//从startIndex开始，避免重复</span><br><span class="line">              path.push(i);</span><br><span class="line">              backTracing(n, k, i + 1); //注意i+1,前面的不再考虑，可看代码随想录的图</span><br><span class="line">              path.pop();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      backTracing(n, k, 1);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="2-电话号码字母数字的组合"><a href="#2-电话号码字母数字的组合" class="headerlink" title="2. 电话号码字母数字的组合"></a>2. 电话号码字母数字的组合</h3><ul>
<li><p>考虑到用字典map存储数字和字母的对应关系</p>
</li>
<li><pre><code class="js">var letterCombinations = function(digits) &#123;
    let map = new Map([//键是数字类型
        [2 ,&#39;abc&#39;],
        [3 , &#39;def&#39;],
        [4 , &#39;ghi&#39;],
        [5 ,&#39;jkl&#39;],
        [6 ,&#39;mno&#39;],
        [7 ,&#39;pqrs&#39;],
        [8 ,&#39;tuv&#39;],
        [9 ,&#39;wxyz&#39;]
    ]);   
    let result = [];
    let path = [];
    let backTracing = function(startIndex, path) &#123;
        if(path.length === digits.length &amp;&amp; path.length !== 0) &#123;
            result.push(path.join(&quot;&quot;));
            return;
        &#125;
        for(let i = startIndex; i &lt; digits.length; i++) &#123;
            let str = map.get(parseInt(digits[i]));//需把string类型的digits中的s转成数字，才能取到
            for(let j = 0; j &lt; str.length; j ++) &#123;
                path.push(str[j]);
                backTracing(i+1, path);
                path.pop();
            &#125;
        &#125;
    &#125;
    backTracing(0, path);
    return result;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">### 3. 组合总和</span><br><span class="line"></span><br><span class="line">* candidate中有重复项，但是答案不可以重复，问题在于如何去重</span><br><span class="line">* 可以发现：</span><br><span class="line">  * 树的同层重复元素，没有必要遍历，因为前面的已经用了</span><br><span class="line">  * 树的树枝上的重复元素可以使用，比如1，1，2</span><br><span class="line">* 借助used数组，used数组表示元素是否被访问，在递归回溯的过程中不断更新used数组</span><br><span class="line">* 当candidates[i] == candidates[i-1]出现重复元素时“</span><br><span class="line">  * 如果used[i-1] == 0， 没用过，则同层，continue不进入递归</span><br><span class="line">  * 如果used[i-1] == 1, 用过，同树枝， 进入递归</span><br><span class="line">* for循环中sum + candidates[i] &lt;= target是**剪枝操作**，当sum + candidates[i]大于targe的时候，就没有必要进入递归，继续找了</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var combinationSum2 = function(candidates, target) &#123;</span><br><span class="line">    var result = new Array().fill().map(() =&gt; new Array());</span><br><span class="line">    var path = new Array()</span><br><span class="line">    var used = new Array(candidates.length).fill(0);//使用used数组</span><br><span class="line">    candidates.sort((a, b) =&gt; a - b);   //对candidate进行排序，重复项相邻</span><br><span class="line"></span><br><span class="line">    var backTracing = (sum, startIndex) =&gt; &#123;</span><br><span class="line">        if(sum &gt; target) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == target) &#123;</span><br><span class="line">            result.push(Array.from(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            if(candidates[i] == candidates[i-1] &amp;&amp; used[i-1] == 0) &#123;</span><br><span class="line">                //只有重复项需要判断，当used[i-1]没有使用过的时候，同层，不用使用</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.push(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            used[i] = 1;    //更新used数组</span><br><span class="line">            backTracing(sum, i + 1);</span><br><span class="line">            path.pop();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            used[i] = 0; //更新used数组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backTracing(0, 0);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><h3 id="4-分割回文串"><a href="#4-分割回文串" class="headerlink" title="4. 分割回文串"></a>4. 分割回文串</h3><ul>
<li><p>暴力法无法穷举，换一种思路，采用回溯法这种暴力法</p>
</li>
<li><p>分割回文串的过程，就像组合问题一样。</p>
</li>
<li><p>难点：递归循环过程中如何截取子串</p>
</li>
<li><p>关于模拟切割线，其实就是index是上一层已经确定了的分割线，i是这一层试图寻找的新分割线</p>
</li>
<li><img src="/2024/06/09/leetcode/分割回文串.jpg" style="zoom:67%;">
</li>
<li><p>startIndex即是切割的位置，回溯递推终止条件就是，startIndex到末尾</p>
</li>
<li><p>回文串的区间是startIndex到 i </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isHuiWen = <span class="keyword">function</span>(<span class="params">s, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left] != s[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> partition = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>().<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>());</span><br><span class="line">    <span class="keyword">var</span> path = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">backTracing</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex == s.<span class="property">length</span>) &#123;<span class="comment">//startIndex即是切割的位置</span></span><br><span class="line">            result.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = startIndex; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_">isHuiWen</span>(s,startIndex, i)) <span class="keyword">continue</span>;<span class="comment">//回文串的区间是startIndex到i</span></span><br><span class="line">            path.<span class="title function_">push</span>(s.<span class="title function_">substring</span>(startIndex, i+<span class="number">1</span>));</span><br><span class="line">            <span class="title function_">backTracing</span>(i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-复原IP地址"><a href="#5-复原IP地址" class="headerlink" title="5. 复原IP地址"></a>5. 复原IP地址</h3><ul>
<li>把字符串切割为ip地址。就是对字符串进行分割<ul>
<li>终止条件：当path.length &#x3D;&#x3D;4<ul>
<li>index!&#x3D; s.length的时候，终止，</li>
<li>index &#x3D;&#x3D; s.length 得到答案</li>
</ul>
</li>
<li>横向for循环，startIndex切割字符串，注意切割长度不大于3，所以有i &lt;&#x3D; startIndex + 2</li>
<li>竖向递归深度： backTracing(i+1),从上个切割点的后面开始，</li>
<li>切割字符串索引：s.substring(startIndex, i + 1)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>().<span class="title function_">fill</span>();</span><br><span class="line">    <span class="keyword">var</span> path = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">backTracing</span> = (<span class="params">startIndex</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(startIndex == s.<span class="property">length</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>(path.<span class="title function_">join</span>(<span class="string">&quot;.&quot;</span>));    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = startIndex; i &lt;= startIndex + <span class="number">2</span>  &amp;&amp; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[startIndex] == <span class="number">0</span> &amp;&amp; i != startIndex) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">var</span> child = s.<span class="title function_">substring</span>(startIndex, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">parseInt</span>(child) &gt; <span class="number">255</span>) <span class="keyword">break</span>;</span><br><span class="line">            path.<span class="title function_">push</span>(child);</span><br><span class="line">            <span class="title function_">backTracing</span>(i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><h3 id="6-求子集个数"><a href="#6-求子集个数" class="headerlink" title="6. 求子集个数"></a>6. 求子集个数</h3><ul>
<li><p>1类题：数组不包含重复元素，求子集个数（典型回溯法，画树形图，就很好理解写代码，都是模板。注意点每扩展一个节点都要加入path)</p>
</li>
<li><p>2类题：数组中包含重复元素，求子集个数。（数组去重，先对数组进行排序，使用used数组，分为树枝去重和树层去重。也可以不适用used数组，直接判断同层是否有相邻的相等元素即可。见代码随想录）(对比递增子序列的去重)</p>
</li>
<li><pre><code class="javascript">/**
 * 有重复元素，树的同层不能重复取，但是树枝可以重复取
 * 树层去重和树枝去重
 * 去重需要排序
 */
var subsetsWithDup = function(nums) &#123;
    var result = [];
    var path = [];
    var used = new Array(nums.length).fill(0);
    nums.sort((a, b) =&gt; a - b); //排序

    var backTracing = (startIndex) =&gt; &#123;
        result.push([...path]);
        if(startIndex == nums.length) &#123;
            return;
        &#125;

        for(var i = startIndex; i &lt; nums.length; i++) &#123;
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i-1] == 0) continue;
            path.push(nums[i]);
            used[i] = 1;
            backTracing(i + 1);
            path.pop();
            used[i] = 0;
        &#125;
    &#125;
    backTracing(0);
    return result;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* </span><br><span class="line"></span><br><span class="line">### 7.递增子序列</span><br><span class="line"></span><br><span class="line">* 给定一个数组，找出数组中所有的递增子序列，子序列长度最小为2.(数组中有重复元素)</span><br><span class="line">* 不能对数组排序后，采用used判断是同树层还是同树枝。所以需要采用额外的标记，表示同层的节点（判断同层是否出现了重复元素）</span><br><span class="line">* 解决方法：设置一个标记，当数出现后，就将其标志位置为1。</span><br><span class="line">  * 由于只是同层限制，所以在for循环内部置为1。在for循环外部要重新声明。新的一层uset都会重新定义（清空），uset只负责本层！</span><br><span class="line">  * 标志位的使用工具：</span><br><span class="line">    1. map：key为`nums[i]`,`value`为`i`索引。这样就可以判断是否已经出现`nums[i]`。</span><br><span class="line">       * map.get()、map.has()函数</span><br><span class="line">    2. set：set中不能有重复元素。set.insert()</span><br><span class="line">       * const uset = new Set();</span><br><span class="line">        * uset.add()、uset.has()、uset.delete()、uset.clear()</span><br><span class="line">    3. 数组：因为数组也是一种哈希表，题目中nums[i]在-100到100之间，可以将其映射到0到200之间</span><br><span class="line">       * let uarr = new Array();</span><br><span class="line">       * uarr[nums[i] + 100] = true;</span><br><span class="line">* 注意点：同层的标志，uset在哪里重新定义，在哪里赋值</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var findSubsequences = function(nums) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    var path = [];</span><br><span class="line"></span><br><span class="line">    var backTracing = (startIndex) =&gt; &#123;</span><br><span class="line">        if(path.length &gt; 1) result.push([...path]); //序列长度至少为2,所以对path.length进行判断</span><br><span class="line">        if(startIndex == nums.length) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var map = new Map();       //使用map做映射</span><br><span class="line">        for(var i = 0; i &lt; nums.length; i++) &#123;   </span><br><span class="line">            map.set(nums[i], -1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //let uset = []     //使用数组作为映射</span><br><span class="line">        for(var i = startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if(map.get(nums[i]) &gt;= 0 ) continue;   //同层出现过了，就不在重复取</span><br><span class="line">           // if(uset[nums[i] + 100] ) continue;</span><br><span class="line">            </span><br><span class="line">            if(path.length &gt; 0 &amp;&amp; nums[i] &lt; path[path.length - 1]) continue;</span><br><span class="line">            //递增序列。注意这里nums[i]是和path中的最后一个元素相比</span><br><span class="line">            </span><br><span class="line">          //  uset[nums[i] + 100] = true</span><br><span class="line">            map.set(nums[i], i);    //同层使用过了，要设置标志位</span><br><span class="line"></span><br><span class="line">            path.push(nums[i]);</span><br><span class="line">            backTracing(i + 1);</span><br><span class="line">            path.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backTracing(0);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * 递增子序列就是求子集，但是要求长度至少为2</span><br><span class="line"> * 有重复元素，同层不能出现相同元素，但是不能对数组排列，需要使用标记，使用map</span><br><span class="line"> * 同层出现了重复元素就不再比较，但是同树枝出现重复元素，还是要比较的。</span><br><span class="line"> * 这里需要判断同层是否出现相同元素，如果同层出现了相同元素，那么就不比较。</span><br><span class="line"> * 如何判断同层出现相同元素，设置map，在for循环的外面，对map进行赋初值，遍历到元素的时候，对map进行标志</span><br><span class="line"> * 那么等到了同层的相同元素的时候，就可以判断map的标志从而得出是否在同层使用过</span><br><span class="line">  */</span><br><span class="line">var findSubsequences = function(nums) &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let path = [];</span><br><span class="line"></span><br><span class="line">    let backTracing = function(startIndex) &#123;</span><br><span class="line">        if(path.length &gt; 1 ) &#123;</span><br><span class="line">            result.push([...path]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let map = new Map();</span><br><span class="line">        for(let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.set(nums[i], false);//注意map的位置</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(let i = startIndex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if(map.get(nums[i])) continue;//说明使用过</span><br><span class="line">            if(path.length &gt;= 1 &amp;&amp; nums[i] &lt; path[path.length - 1]) continue;</span><br><span class="line"></span><br><span class="line">            path.push(nums[i]);</span><br><span class="line">            map.set(nums[i], true);</span><br><span class="line">            backTracing(i+ 1);</span><br><span class="line">            path.pop();//注意这里没有把map置为false哦，因为是同层</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backTracing(0);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><ul>
<li><strong>排列问题虽然位置不同是不同的答案，但是要求元素不能重复使用。所以要使用used数组</strong></li>
<li>used数组除了可以用于判断是否出现重复元素（树枝），也可以用于当nums有重复元素时，树层上去重</li>
</ul>
<h3 id="8-全排列"><a href="#8-全排列" class="headerlink" title="8. 全排列"></a>8. 全排列</h3><ul>
<li>给定一个没有重复元素的数组，求所有的排列</li>
<li>排列问题，不需要starIndex，从0开始，借助used数组即可</li>
<li>used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。判断是否同树枝出现过</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>().<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>());</span><br><span class="line">    <span class="keyword">var</span> path = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="comment">//used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。</span></span><br><span class="line">    <span class="keyword">var</span> used = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">backTracing</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> == nums.<span class="property">length</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//判断是否同树枝出现过，使用used数组即可</span></span><br><span class="line">            path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="title function_">backTracing</span>();</span><br><span class="line">            path.<span class="title function_">pop</span>()</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-全排列2"><a href="#9-全排列2" class="headerlink" title="9. 全排列2"></a>9. 全排列2</h3><ul>
<li><p>含有重复元素的全排列</p>
</li>
<li><p>涉及到树层去重的问题。两种方法，<strong>去重两种方法：</strong></p>
<ol>
<li><p>使用set,map,数组做标志位</p>
</li>
<li><p><strong>对元素进行排序，方便通过相邻的节点来判断是否重复使用了</strong></p>
</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permuteUnique = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> path = [];</span><br><span class="line">    <span class="keyword">var</span> used = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">backTracing</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="property">length</span> == nums.<span class="property">length</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>([...path]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> uarr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">21</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(uarr[nums[i] + <span class="number">10</span>] || used[i]) <span class="keyword">continue</span>;<span class="comment">//注意这里用数组做标志位时，索引的用法</span></span><br><span class="line"></span><br><span class="line">            uarr[nums[i] + <span class="number">10</span>] = <span class="literal">true</span>;  <span class="comment">//uarr用于标记同层是否重复出现</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;     <span class="comment">//used用于判断同树枝是否重复使用，比如111的情况</span></span><br><span class="line">            path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">backTracing</span>();</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracing</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果。</p>
</li>
<li><p>树层去重有两种方法，<strong>去重两种方法：</strong></p>
<ol>
<li><p>使用set,map,数组做标志位</p>
</li>
<li><p><strong>对元素进行排序，方便通过相邻的节点来判断是否重复使用了</strong></p>
</li>
</ol>
</li>
</ol>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li>动态规划每一个状态是由前一个状态推导出来的，是确定的（贪心没有状态推到，直接局部最优）</li>
<li>动态规划的五部曲<ul>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ul>
</li>
</ul>
<h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1. 斐波那契数列"></a>1. 斐波那契数列</h3><ul>
<li><p>递推公式：dp[i] &#x3D; dp[i - 1] + dp[i - 2] ;</p>
</li>
<li><pre><code class="javascript">if(n &lt;= 1) return n;
var dp = new Array();
dp[0] = 0;
dp[1] = 1;
for(var i = 2; i &lt;= n; i++) &#123;
    dp[i] = dp[i - 1] + dp[i - 2];
&#125;
return dp[n];
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 爬楼梯</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"> /**</span><br><span class="line"> * dp[i] = Math.min(dp[i-1] + cost[i-1] , dp[i-2] + cost[i-2])</span><br><span class="line"> dp[0] = 0</span><br><span class="line"> dp[1] = 0;</span><br><span class="line">  */</span><br><span class="line">var minCostClimbingStairs = function(cost) &#123;</span><br><span class="line">    let dp = new Array(cost.length + 1).fill(0);</span><br><span class="line">    for(let i = 2; i &lt;cost.length + 1; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i-1] + cost[i-1] , dp[i-2] + cost[i-2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[cost.length];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="2-整数拆分"><a href="#2-整数拆分" class="headerlink" title="2. 整数拆分"></a>2. 整数拆分</h3><ul>
<li><p>居然可以用动态规划解这道题！！！</p>
</li>
<li><p>思路：</p>
<ul>
<li><p>先考虑把一个数拆分成两份，求最大乘积的话，</p>
<ul>
<li>那么就是遍历该数，j从0到i穷举所有的情况</li>
</ul>
</li>
<li><p>那么把一个数参分成两个及以上的的，</p>
<ul>
<li><p>就是拿到j之后，对于剩下的i-j，继续拆分。这样就有了动态规划的思想</p>
</li>
<li><p>dp数组：dp[i]代表拆分数i得到的最大乘积</p>
</li>
<li><p>递推公式：dp[i] &#x3D;max(dp[i], max(j * (i-j), j * dp[i - j]))</p>
<ul>
<li>公式中有dp[i]是因为，再不断循环j的过程中，不断更新dp[i]的值</li>
</ul>
<ol start="3">
<li>确定遍历顺序，dp[i]需要由dp[i-j]得到，所以 i 从前往后遍历,先有dp[i - j]再有dp[i]。</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> integerBreak = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;<span class="comment">//i用于列举n的情况，一直遍历到n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;<span class="comment">//j用于拆分</span></span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], <span class="title class_">Math</span>.<span class="title function_">max</span>(j*(i-j), j*dp[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="0-1背包理论"><a href="#0-1背包理论" class="headerlink" title="0-1背包理论"></a>0-1背包理论</h3><ul>
<li><img src="/2024/06/09/leetcode/背包问题分类.jpg" style="zoom:80%;"></li>
<li>有物品0，1，2….，每个物品的重量weight[i]，每个物品的价值为value[i]。背包的承重为j，求在背包承重范围内，所能得到的最大价值</li>
<li>01背包一定是外层for循环遍历物品，内层for循环遍历背包容量<strong>且从后向前遍历</strong>！</li>
</ul>
<ol>
<li><p>采用二维数组<code>dp[i][j]</code>表示承重为<code>j</code>, 在物品<code>0-i</code>中选择，所能得到的最大价值</p>
<ul>
<li><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i-1]]+ value[i])</code></li>
<li>表示在承重<code>j</code>时，不包含物品<code>i-1</code>；以及包含物品<code>i-1</code>的情况</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testWeightBagProblem</span> (weight, value, size) &#123;<span class="comment">//size代表承重</span></span><br><span class="line">    <span class="comment">// 定义 dp 数组</span></span><br><span class="line">    <span class="keyword">const</span> len = weight.<span class="property">length</span>,</span><br><span class="line">          dp = <span class="title class_">Array</span>(len).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Array</span>(size + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));<span class="comment">//注意dp数组的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = weight[<span class="number">0</span>]; j &lt;= size; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight 数组的长度len 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= size; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">table</span>(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>][size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>采用一维数组<code>dp[j]</code>表示承重为<code>j</code>时，所能得到的最大价值</p>
<ul>
<li><code>dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testWeightBagProblem</span>(<span class="params">wight, value, size</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = wight.<span class="property">length</span>, </span><br><span class="line">    	dp = <span class="title class_">Array</span>(size + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = size; j &gt;= wight[i - <span class="number">1</span>]; j--) &#123;<span class="comment">//注意j是从后往前开始遍历的</span></span><br><span class="line">      dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], value[i - <span class="number">1</span>] + dp[j - wight[i - <span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-分割等和子集"><a href="#3-分割等和子集" class="headerlink" title="3. 分割等和子集"></a>3. 分割等和子集</h3><ul>
<li><p>给定一个数组，将该数组分割成两个和相等的子集</p>
</li>
<li><p>解法一：相当于找到几个数相加，使其和为sum&#x2F;2。可用回溯解决，但是回溯是暴力法，可想想别的</p>
</li>
<li><p>解法二：动态规划，总承重为sum&#x2F;2，物品为<code>nums[i]</code>，价值为nums[i]</p>
<ul>
<li>01背包问题，物品不重复。找到几个数的和为target</li>
</ul>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<ol>
<li>dp数组：dp[j]:表示背包中承重为j时，能得到的最大收益，能够背的最大重量为dp[j]。</li>
<li>本题中dp[j]表示和为j时，物品的和</li>
<li>那么本题的目标是dp[target] 能否等于 target 。如果等于的话，说明可以等和分割</li>
</ol>
</li>
<li><p>确定递推公式</p>
<ul>
<li><code>dp[j] = max(dp[j], dp[j-nums[i]] + nums[i])</code></li>
</ul>
</li>
<li><p>dp初始化</p>
<ul>
<li><code>dp[0] = 0</code></li>
</ul>
</li>
<li><p>确定遍历顺序</p>
<ul>
<li>如果使用一维数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canPartition = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        target += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    target = target/<span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);<span class="comment">//需要设置dp数组的长度？？？？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-最后一块石头的重量"><a href="#4-最后一块石头的重量" class="headerlink" title="4. 最后一块石头的重量"></a>4. 最后一块石头的重量</h3><ul>
<li>本题巧妙点在于，要想使得最后的石头重量最小，相当于把石头堆分为两份，这两份之间的最小差异就是最后石头的重量</li>
<li>那么问题就转化为：背包容量为 ⌊sum&#x2F;2⌋,物品重量和价值均为 stones[i]的 0-1 背包问题</li>
<li><code>dp[sum/2]</code>表示承重为sum&#x2F;2时，能得到的最大的石头重量为dp[sum&#x2F;2]</li>
<li>那么最后sum-dp[sum&#x2F;2]-dp[sum&#x2F;2]就是最后石头的最小重量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路很巧妙，因为当把石头堆分成两堆后，两堆之间的差异就是最后的石头重量</span></span><br><span class="line"><span class="comment"> * 那么目的要使两堆差异尽可能小。那么理想情况是，两堆的和均为sum的一般，那么正好抵消</span></span><br><span class="line"><span class="comment"> * 但有可能出现一堆的和在sum附近。那么目标就是使得当承重为sum/2的时候，dp[sum/2]尽可能的大，</span></span><br><span class="line"><span class="comment"> * 就是石头的重量尽可能的大。dp[sum/2]表示石头的重量</span></span><br><span class="line"><span class="comment"> * dp[j] = dp[j], dp[j- stones[i]] + stones[i]</span></span><br><span class="line"><span class="comment"> * 初始情况dp为0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> lastStoneWeightII = <span class="keyword">function</span>(<span class="params">stones</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; stones.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += stones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1501</span>).<span class="title function_">fill</span>(<span class="number">0</span>);<span class="comment">//由于承重最大为30*150,这里除以2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; stones.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum/<span class="number">2</span>); j &gt;= stones[i]; j--) &#123;</span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-stones[i]] + stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> sum - dp[target] - dp[target];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-目标和"><a href="#5-目标和" class="headerlink" title="5. 目标和"></a>5. 目标和</h3><ul>
<li>加法、减法进行组合，求目标和target时，有多少种组合方法</li>
<li>求组合方法，有两种解法：<ul>
<li>解法一：回溯法，暴力搜索，可以得到组合的path，详细内容</li>
<li>解法二：动态规划，可以得到组合的总数。递推公式：<code>dp[j] += dp[j-nums[i]]</code>(求背满背包有几种方式)</li>
</ul>
</li>
<li><strong>思路：</strong>加法总和为x，减法总和则为<code>target-x</code>。这样<code>x+(target-x) = target</code>（重点部分，转不过来弯）<ul>
<li>而<code>x-(target-x)  = sum</code>(加法数量 +减法的数量之和为sum)，则<code>x = (sum + target)/2</code>。</li>
<li>问题转换为求几个数的组合，使其和为x，这种组合有多少种</li>
</ul>
</li>
<li><strong>解法一：</strong>回溯法，找到每一种组合，并计数。暴力解法</li>
<li><strong>解法二：</strong>动态规划，<ol>
<li><code>dp[j]</code> 表示和为j时，组合的总数</li>
<li>如果有一个<code>nums[i]</code>，那么<code>dp[j-nums[i]]</code>代表和为<code>j-nums[i]</code>的组合数。<ul>
<li>那么<code>dp[j] = dp[j-nums[i]]</code>,所以循环<code>i</code></li>
</ul>
</li>
<li>dp[0] &#x3D; 1,如果数组[0] ，target &#x3D; 0，那么 bagSize &#x3D; (target + sum) &#x2F; 2 &#x3D; 0。 dp[0]也应该是1</li>
<li>遍历顺序，内层<code>j</code>从<code>x</code>到<code>nums[i]</code>,倒叙遍历,升序遍历,外层<code>i</code>从<code>0</code>到<code>nums.length</code></li>
</ol>
</li>
<li><strong>注意点：</strong>当target&gt; sum 时，无解，返回0</li>
<li>当（sum + target）%2 为1的时候，无解，返回0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findTargetSumWays = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(target) &gt; sum ) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意这里对target取绝对值</span></span><br><span class="line">    <span class="keyword">if</span>((target + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> x = (target + sum) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(x+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//初始化dp[0] 为1，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = x; j - nums[i] &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[3]:3个节点组成的二叉搜索树的个数</span></span><br><span class="line"><span class="comment"> * dp[3] = 以1为头节点时搜索树的数量即为,右子树有2个节点的二叉树数目* 左子树有零个节点的二叉树的数目。即dp[2] * dp[0](这里dp[0] = 1)</span></span><br><span class="line"><span class="comment"> * 以2为头节点时的搜索树的数量，即为左子树有一个，右子树有一个。dp[1] * dp[1]</span></span><br><span class="line"><span class="comment"> * 以3为头节点的数据，即左子树有两个节点* 右子树有零个节点dp[2] * dp[0]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 那么递推公式dp[i] = dp[j] * dp[i-j - 1]。这里是i-j-</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> numTrees = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+ <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>; j &lt; i; j++ ) &#123;</span><br><span class="line">            dp[i] += dp[j] * dp[i-j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-一和零"><a href="#6-一和零" class="headerlink" title="6. 一和零"></a>6. 一和零</h3><ul>
<li><p>找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 </p>
</li>
<li><p>思路：动态规划？找限制，最大的限制？最多有m个0和n个1，</p>
<ul>
<li>所以有两个维度的背包，两个背包的最大容量，分别为m和n</li>
</ul>
<ol>
<li>采用二维数组<code>dp[i][j]</code>:表示承重为<code>i</code>个<code>0</code>和<code>j</code>个<code>1</code>的背包中，得到的最大子集长度为<code>dp[i][j]</code>;</li>
<li><code>dp[i][j] = max(dp[i-zero[y]][j-one[y]] + 1, dp[i][j])</code>取最大值（这里的1相当于物品的价值）</li>
<li><code>dp[0][0] = 0</code>;</li>
</ol>
</li>
<li><p>m和n代表承重，物品是子串（01背包问题）</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaxForm = <span class="keyword">function</span>(<span class="params">strs, m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> zero = <span class="keyword">new</span> <span class="title class_">Array</span>(strs.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> one = <span class="keyword">new</span> <span class="title class_">Array</span>(strs.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = strs[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; str.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="number">0</span>) zero[i] ++</span><br><span class="line">            <span class="keyword">else</span> one[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; strs.<span class="property">length</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = m; i &gt;= zero[y]; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = n; j &gt;= one[y]; j--) &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i][j] , dp[i-zero[y]][j-one[y]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="01背包总结"><a href="#01背包总结" class="headerlink" title="01背包总结"></a>01背包总结</h3><ul>
<li>01背包一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</li>
</ul>
<ul>
<li>纯 0 - 1 背包 是求 给定背包容量 装满背包 的最大价值是多少。</li>
<li>416.分割等和子集 是求 给定背包容量，能不能装满这个背包。<ul>
<li><code>dp[j] = max(dp[j], dp[j-nums[i]] + nums[i])</code></li>
</ul>
</li>
<li>1049 最后一块石头的重量 II 是求 给定背包容量，尽可能装，最多能装多少<ul>
<li><code>dp[j] = Math.max(dp[j], dp[j-stones[i]] + stones[i])</code>;</li>
</ul>
</li>
<li>494 目标和 是求 给定背包容量，装满背包有多少种方法。<ul>
<li><code>dp[j] += dp[j-nums[i]]</code></li>
</ul>
</li>
<li>1和零是求 给定背包容量，装满背包最多有多少个物品。<ul>
<li><code>dp[i][j] = max(dp[i-zero[y]][j-one[y]] + 1, dp[i][j])</code></li>
</ul>
</li>
</ul>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><ul>
<li>完全背包：一个物品可以选多个</li>
<li>与01背包的区别在于：<strong>遍历顺序，<code>j</code>的遍历是从小到大</strong>。01背包<code>j</code>的顺序是从大到小</li>
<li>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</li>
</ul>
<h3 id="7-零钱兑换"><a href="#7-零钱兑换" class="headerlink" title="7. 零钱兑换"></a>7. 零钱兑换</h3><ul>
<li><p>不同面额的硬币可以选多个，求凑成总和为amount的方式有几种？</p>
</li>
<li><p>思路：其实就是求凑成总和的组合数有几种。递推公式<code>dp[j] += dp[j-nums[i]]</code></p>
</li>
<li><p>遍历顺序：必须是外层遍历物品，内层遍历总和。不可以反过来。如果反过来就是求排列数了</p>
<ul>
<li><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其实也是组合问题，但是回溯法是暴力算法，可以采用动态规划</span></span><br><span class="line"><span class="comment"> * 这是变相的背包问题，背包的容量为amount，物品为面额，</span></span><br><span class="line"><span class="comment"> * 注意是求组合数，不是排列数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. dp[j]表示：背包所承受的面额总和为j时，背包中物品的组合总数</span></span><br><span class="line"><span class="comment"> * 2. dp[j] = dp[j] + dp[j-coins[i]]</span></span><br><span class="line"><span class="comment"> *    遍历coins[i】并相加，和目标和那一题一样</span></span><br><span class="line"><span class="comment"> * 3. dp[0] = 1，因为如果为0的话，后面的dp[j]无法更新</span></span><br><span class="line"><span class="comment"> * 4. 遍历顺序：由于一个物品可以选多个，是完全背包，j从小到大遍历</span></span><br><span class="line"><span class="comment"> * 5. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> change = <span class="keyword">function</span>(<span class="params">amount, coins</span>) &#123;</span><br><span class="line">    coins.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(amount + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; coins.<span class="property">length</span>; i++) &#123;<span class="comment">//先遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = coins[i]; j &lt;= amount; j++) &#123;<span class="comment">//再遍历容量，因为是求组合数，不是求排列数</span></span><br><span class="line">            dp[j] += dp[j-coins[i]];</span><br><span class="line">            <span class="comment">//console.log(&quot;dp[&quot; + j + &quot;]:&quot;+j);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-组合总和"><a href="#8-组合总和" class="headerlink" title="8. 组合总和"></a>8. 组合总和</h3><ul>
<li>找出和为给定目标正整数的组合的个数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目是求组合，其实是排列，可以用回溯法，但也可以用动态规划</span></span><br><span class="line"><span class="comment"> * 背包容量为target,物品为数字，求装满背包有几种装法？</span></span><br><span class="line"><span class="comment"> * dp[j]:表示总和为j时，组合的个数</span></span><br><span class="line"><span class="comment"> * dp[j] = dp[j-nums[i]]遍历i</span></span><br><span class="line"><span class="comment"> * 遍历顺序：由于是完全背包，所以j从小到大遍历。</span></span><br><span class="line"><span class="comment"> *          由于是排列，所以外层遍历背包容量，内层遍历物品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; target + <span class="number">1</span>; j++) &#123;<span class="comment">//外层遍历背包容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;<span class="comment">//内层遍历物品</span></span><br><span class="line">           <span class="keyword">if</span>(j &gt;= nums[i]) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-单词拆分"><a href="#9-单词拆分" class="headerlink" title="9. 单词拆分"></a>9. 单词拆分</h3><ul>
<li><p>注意本题的递推公式的思路</p>
</li>
<li><p>本题要求的是排列，不是组合，因为物品的排列会对结果有影响</p>
</li>
<li><pre><code class="javascript">/**
 * 可以采用回溯法，for循环，直至wordDict进行拼接后得到s
 * 思路梳理：相当于把字典wordDict中的进行拼接，拼成s。
 *          wordDict相当于物品，每个物品可以重复取，（完全背包），物品取出后需要拼接为s
 * 
 * dp[j]：表示s[0:j]是否可以有wordDict组成
 * dp[j] = dp[j-wordDict[i].length ] &amp;&amp; s[j-wordDict[i].length : j]== wordDict[i]
 * 
 * dp[0] = s[0 : 1]是否在字典中
 * 
 * 遍历方式：字典是物品， j是背包承重。外层遍历物品，内层遍历承重，承重从小到大 
 * 
 * 注意点：本题要求的是排列，不是组合，因为物品的排列会对结果有影响
 * &quot;apple&quot;, &quot;pen&quot; 是物品，那么我们要求 物品的组合一定是 &quot;apple&quot; + &quot;pen&quot; + &quot;apple&quot; 才能组成 &quot;applepenapple&quot;。
*  apple&quot; + &quot;apple&quot; + &quot;pen&quot; 或者 &quot;pen&quot; + &quot;apple&quot; + &quot;apple&quot; 是不可以的，那么我们就是强调物品之间顺序。
 */
var wordBreak = function(s, wordDict) &#123;
    var dp = new Array(s.length + 1).fill(false);
    dp[0] = true;
    
    for(var j = 0 ; j &lt;= s.length; j++) &#123;
         
        for(var i = 0; i &lt; wordDict.length; i++)&#123;
            if(dp[j - wordDict[i].length] &amp;&amp; s.substring(j - wordDict[i].length, j) 
                   === wordDict[i]) &#123;
                dp[j] = true;
                
            &#125;
            console.log(&quot;dp[&quot; + j + &quot;]：&quot; + dp[j]);
        &#125;
    &#125;
    return dp[s.length ];
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 10. 打家劫舍</span><br><span class="line"></span><br><span class="line">* 给定一个代表每个房屋存放金额的非负整数数组，计算你在不偷相邻房间的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line">* 思路：考虑是否偷当前节点，</span><br><span class="line">  * 如果偷的话，那么前一个节点就不能考虑。`dp[j - 2] +nums[j]`</span><br><span class="line">  * 如果不偷的话，`dp[j-1]`</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">/**</span><br><span class="line"> * dp[j] :表示从0到j区间内，能够偷盗的最大金额</span><br><span class="line"> * dp[j] = max(dp[j-1] , dp[j - 2] +nums[j]) </span><br><span class="line"> * 递推公式：从偷当前状态i房间和不偷当前状态i房间推导</span><br><span class="line"> * </span><br><span class="line"> * dp[0] = nums[0]</span><br><span class="line"> * dp[1] = Math.max(nums[0], nums[1])</span><br><span class="line"> */</span><br><span class="line">var rob = function(nums) &#123;</span><br><span class="line">    if(nums.length == 1) return nums[0];</span><br><span class="line">    else if(nums.length == 2) return Math.max(nums[0], nums[1]);</span><br><span class="line">    var dp = new Array(nums.length).fill(0);</span><br><span class="line">    dp[0] = nums[0];</span><br><span class="line">    dp[1] = Math.max(nums[0], nums[1]);;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(var i = 2; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.length - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="11-打家劫舍2"><a href="#11-打家劫舍2" class="headerlink" title="11. 打家劫舍2"></a>11. 打家劫舍2</h3><ul>
<li>首尾相连</li>
<li>成环之后，首尾元素不能同时偷，也就是有首没尾，有尾没首</li>
<li>所以首和尾分开考虑，分两种情况，<ul>
<li>一种是考虑首元素时</li>
<li>一种是考虑尾元素时，</li>
<li>最终结果取二者的最大值</li>
</ul>
</li>
</ul>
<h3 id="12-打家劫舍3"><a href="#12-打家劫舍3" class="headerlink" title="12. 打家劫舍3"></a>12. 打家劫舍3</h3><ul>
<li><p>房屋排列是一颗二叉树</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一：递归法（树当然要用递归，后序遍历） 但超时</span></span><br><span class="line"><span class="comment"> * 思路：树的话，考虑遍历方式，采用后序遍历，通过递归函数返回值做下一步计算</span></span><br><span class="line"><span class="comment"> * 打家劫舍就是分两种情况</span></span><br><span class="line"><span class="comment"> *  * 偷当前节点，那么最大收益等于= 当前节点的值 + 左右孩子的孩子的收益</span></span><br><span class="line"><span class="comment"> *  * 不偷当前节点，最大收益等于= 左右孩子的收益 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 方法二：动态规划</span></span><br><span class="line"><span class="comment"> * 由于递归中存在重复计算，先计算孙子节点，然后计算孩子节点，重复了</span></span><br><span class="line"><span class="comment"> * 动态规划其实就是使用状态转移容器来记录状态的变化，</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 重点：在树上进行状态转移</span></span><br><span class="line"><span class="comment"> * 方法：使用一个长度为2的数组，计算当前节点偷和不偷获得的最大收益</span></span><br><span class="line"><span class="comment"> * 递归函数返回值：数组</span></span><br><span class="line"><span class="comment"> * 1. 偷当前节点， cur.val + cur.left[0] + cur.right[0] 不偷左右孩子</span></span><br><span class="line"><span class="comment"> * 2. 不偷当前节点， max(cur.left[0],cur.left[1]) + max(cur.right[0],cur.right[1]) </span></span><br><span class="line"><span class="comment"> *    (不偷当前节点的时候，左右节点可以偷，也可以不偷，所以取最大值)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">//方法一：递归</span></span><br><span class="line">    <span class="comment">// if(!root) return 0;</span></span><br><span class="line">    <span class="comment">// if(!root.left &amp;&amp; !root.right) return root.val;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// var val1 = root.val;</span></span><br><span class="line">    <span class="comment">// if(root.left) &#123;</span></span><br><span class="line">    <span class="comment">//    val1 += rob(root.left.left) + rob(root.left.right);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// if(root.right) &#123;</span></span><br><span class="line">    <span class="comment">//     val1 += rob(root.right.left) + rob(root.right.right);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// var val2 = 0;</span></span><br><span class="line">    <span class="comment">// val2 = rob(root.left) + rob(root.right);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return Math.max(val1, val2);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：动态规划</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">myrob</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span>) <span class="keyword">return</span> [<span class="number">0</span>, node.<span class="property">val</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = <span class="title function_">myrob</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">var</span> right = <span class="title function_">myrob</span>(node.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> val2 = node.<span class="property">val</span>;    <span class="comment">//偷当前节点</span></span><br><span class="line">        val2 = val2 + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> val1 = <span class="number">0</span>;       <span class="comment">//不偷当前节点</span></span><br><span class="line">        val1 = <span class="title class_">Math</span>.<span class="title function_">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="title class_">Math</span>.<span class="title function_">max</span>(right[<span class="number">0</span>],right[<span class="number">1</span>])<span class="comment">//左右孩子可以偷也可以不偷，取最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [val1, val2];<span class="comment">//返回数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="title function_">myrob</span>(root);</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>] &gt; result[<span class="number">1</span>] ? result[<span class="number">0</span>] : result[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-买卖股票的最佳时机"><a href="#13-买卖股票的最佳时机" class="headerlink" title="13. 买卖股票的最佳时机"></a>13. 买卖股票的最佳时机</h3><ul>
<li>该题只买入一次，卖出一次。不重复购买</li>
<li>使用二维数组，表示第i天持有股票和不持有股票的最多现金</li>
<li>注意状态的表示，每个节点即可持有股票，也可不持有股票</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划：采用二维数组，表示在第i天持有股票所得的最多现金。和在第i天不持有股票所得的最多现金</span></span><br><span class="line"><span class="comment"> * 1. dp[i][0]：持有股票所得的最多现金</span></span><br><span class="line"><span class="comment"> *   分两种情况：1是第i天买入股票，则第i-1天不持有股票，即- prices[i]</span></span><br><span class="line"><span class="comment"> *              2是第i天不买入股票，则第i-1天一定持有股票，即dp[i-1][0]</span></span><br><span class="line"><span class="comment"> *     dp[i][0] = max(dp[i-1][0], -prices[i])</span></span><br><span class="line"><span class="comment"> * 2. dp[i][1]：第i天不持有股票所得的最多现金</span></span><br><span class="line"><span class="comment"> *   分两种情况：1是第i天卖出股票，则第i-1天持有股票。即dp[i-1][0] + prices[i]</span></span><br><span class="line"><span class="comment"> *              2是第i天没卖股票，第i-1天就没有股票。即dp[i-1][1]</span></span><br><span class="line"><span class="comment"> *      dp[i][1] = max(dp[i-1][0] + prices[i], dp[i-1][1])</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3. 初始情况：dp[0][0] = -prices[0]</span></span><br><span class="line"><span class="comment"> *             dp[0][1] = 0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="comment">//方法二：动态规划，二维数组，表示第i天持有股票和不持有股票的最多现金</span></span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(-prices[i], dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种解法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[j]表示第j天卖出得到的利润</span></span><br><span class="line"><span class="comment"> * 遍历j之前的每一天，找到prices[j] - prices[i]的最大值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; prices.<span class="property">length</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[j] &lt; prices[minIndex]) &#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, prices[j] - prices[minIndex]);</span><br><span class="line">        </span><br><span class="line">        result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="14-买卖股票最佳时机2"><a href="#14-买卖股票最佳时机2" class="headerlink" title="14. 买卖股票最佳时机2"></a>14. 买卖股票最佳时机2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以重复购买：(与前一题的差别在于dp[i][0],如果在i天买入股票，则前几天有可能卖出去过，所以是dp[i-1][1] - prices[i])</span></span><br><span class="line"><span class="comment"> * dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][0]);</span></span><br><span class="line"><span class="comment"> * dp[i][1] = max(prices[i] + dp[i-1][0],  dp[i-1][1])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i], dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i] + dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="15-买卖股票的最佳时机3"><a href="#15-买卖股票的最佳时机3" class="headerlink" title="15. 买卖股票的最佳时机3"></a>15. 买卖股票的最佳时机3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 股票问题，状态的列举</span></span><br><span class="line"><span class="comment"> * 最多交易2次m,每天的状态有四种，分别为第1次持有股票，第1次不持有股票，第2次持有股票。第2次不持有股票</span></span><br><span class="line"><span class="comment"> * dp数组就是对状态的列举，dp数组为二维dp[i][j]，表示第i天的情况，但是j的取值有四种</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 本题做多只能买卖两次。全程用户可能没有买卖、买卖一次、买卖两次</span></span><br><span class="line"><span class="comment"> * 与前几题的差别在于，在第i天，用户的状态不再是持有股票和不持有股票之分，两种状态了</span></span><br><span class="line"><span class="comment"> * 而是在第i天，有4中状态：</span></span><br><span class="line"><span class="comment"> *  1. 第一次持有股票</span></span><br><span class="line"><span class="comment"> *  2. 第一次不持有股票</span></span><br><span class="line"><span class="comment"> *  3. 第二次持有股票</span></span><br><span class="line"><span class="comment"> *  4. 第二次不持有股票</span></span><br><span class="line"><span class="comment"> * 所以dp数组，横向大小为4</span></span><br><span class="line"><span class="comment"> * dp[i][j]: j的取值为1到4，分别表示对应的4中状态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * dp[i][1] = -prices[i], dp[i-1][1]</span></span><br><span class="line"><span class="comment"> * dp[i][2] = prices[i] + dp[i][1] ,  dp[i-1][2]</span></span><br><span class="line"><span class="comment"> * dp[i][3] = -prices[i] + dp[i][2], dp[i-1][3]</span></span><br><span class="line"><span class="comment"> * dp[i][4] = prices[i] + dp[i][3], dp[i-1][4]</span></span><br><span class="line"><span class="comment"> * 注意和prices搭档的不是和i-1相比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(-prices[i], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i] + dp[i][<span class="number">1</span>] ,  dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(-prices[i] + dp[i][<span class="number">2</span>], dp[i-<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i] + dp[i][<span class="number">3</span>], dp[i-<span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="16-买卖股票的最佳时机4"><a href="#16-买卖股票的最佳时机4" class="headerlink" title="16. 买卖股票的最佳时机4"></a>16. 买卖股票的最佳时机4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最多完成k笔交易，则每天有2*k种状态</span></span><br><span class="line"><span class="comment"> * k为奇数，持有股票的状态</span></span><br><span class="line"><span class="comment"> * dp[i][k] = -prices[i] + dp[i][k-1], dp[i-1][k]</span></span><br><span class="line"><span class="comment"> * k为偶数，不持有股票的状态</span></span><br><span class="line"><span class="comment"> * dp[i][k] = prices[i] + dp[i][k-1] ,  dp[i-1][k]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">k, prices</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="property">length</span> == <span class="number">1</span> || prices.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span> * k + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>) &#123;    <span class="comment">//初始化，k为奇数</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i] + dp[i][j-<span class="number">1</span>] ,  dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(-prices[i] + dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">2</span> * k]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="17-买卖股票时机-含冷冻期"><a href="#17-买卖股票时机-含冷冻期" class="headerlink" title="17. 买卖股票时机-含冷冻期"></a>17. 买卖股票时机-含冷冻期</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可重复购买，每天还是两种状态，持有股票和不持有股票</span></span><br><span class="line"><span class="comment"> * 第i天持有股票：dp[i][0] </span></span><br><span class="line"><span class="comment"> *      1. 当天买入 -prices[i] + dp[i-2][1],注意这里是i-2,避过了前一天</span></span><br><span class="line"><span class="comment"> *      2. 前几天买入： dp[i-1][0]</span></span><br><span class="line"><span class="comment"> * 第i天不持有股票: dp[i][1]</span></span><br><span class="line"><span class="comment"> *      1. 当天卖出： prices[i] + dp[i-1][0]</span></span><br><span class="line"><span class="comment"> *      2. 前几天卖出： dp[i-1][1]</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; prices.<span class="property">length</span> + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(-prices[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>][<span class="number">1</span>],  dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i-<span class="number">1</span>] + dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="18-买卖股票时机-含手续费"><a href="#18-买卖股票时机-含手续费" class="headerlink" title="18.买卖股票时机-含手续费"></a>18.买卖股票时机-含手续费</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可重复购买，但有手续费</span></span><br><span class="line"><span class="comment"> * dp[i][0] = -prices[i] + dp[i-1][1] , dp[i-1][0]</span></span><br><span class="line"><span class="comment"> * dp[i][1] = prices[i] + dp[i-1][0] - fee, dp[i-1][1]，注意这里减去了手续费</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices, fee</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(prices.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(-prices[i] + dp[i-<span class="number">1</span>][<span class="number">1</span>] , dp[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i] + dp[i-<span class="number">1</span>][<span class="number">0</span>] - fee, dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.<span class="property">length</span> -<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="股票问题总结"><a href="#股票问题总结" class="headerlink" title="股票问题总结"></a>股票问题总结</h3><ul>
<li>只能买卖1次：</li>
<li>可买卖多次：每天依然是两种状态，就是递推公式和1次有点不同</li>
<li>限制买卖的次数<ul>
<li>可买卖2次：每天是四种状态，分第一次买卖，第二次买卖</li>
<li>可买卖k次：使用循环，每天有<code>2*k</code>种状态，dp数组第二维度长度是<code>2* k</code></li>
</ul>
</li>
<li>冷冻期</li>
<li>手续费</li>
</ul>
<h3 id="19-最长递增子序列"><a href="#19-最长递增子序列" class="headerlink" title="19. 最长递增子序列"></a>19. 最长递增子序列</h3><ul>
<li>遍历小于i的数，找到最大的。递推公式：<code>dp[i] = Math.max(dp[i], dp[j] + 1);</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i]表示从0到i，以i结尾的最长递增子序列的长度， </span></span><br><span class="line"><span class="comment"> * dp[i]：比较nums[i]，从后往前，找到小于nums[i]的数nums[p]，并取dp[p]最大值，</span></span><br><span class="line"><span class="comment"> *        则dp[i] = dp[p] + 1; 所以有两层循环</span></span><br><span class="line"><span class="comment"> *        dp[i] = Math.max(dp[i], dp[j] + 1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;	<span class="comment">//循环j，与前0到i的状态有关，找最大值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = result &gt; dp[i] ? result : dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="20-最长连续递增子序列"><a href="#20-最长连续递增子序列" class="headerlink" title="20. 最长连续递增子序列"></a>20. 最长连续递增子序列</h3><ul>
<li>和上一题的区别，<ul>
<li>递增子序列，多一层循环，用于找到最大值。</li>
<li>连续递增子序列，<code>dp[i]</code>只能由<code>dp[i-1]</code>确定</li>
</ul>
</li>
<li><strong>不连续递增子序列的跟前<code>0-i</code> 个状态有关，连续递增的子序列只跟前一个状态有关</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只需遍历一遍，j和i，如果nums[i] &lt;= nums[i-1], 则j = i, i++(贪心)</span></span><br><span class="line"><span class="comment"> * 也可用动态规划解题：</span></span><br><span class="line"><span class="comment"> * dp[i]表示以i结尾的最长递增序列</span></span><br><span class="line"><span class="comment"> * 如果nums[i] &gt; nums[i-1], 则dp[i] = dp[i-1] + 1; 否则为dp[i] = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">var</span> <span class="variable">findLengthOfLCIS</span> <span class="operator">=</span> function(nums) &#123;</span><br><span class="line">    <span class="comment">//方法一：贪心，遍历一遍。如果nums[i] &gt; nums[i-1]，则len++,否则len为1</span></span><br><span class="line">    <span class="comment">// let max = 1;</span></span><br><span class="line">    <span class="comment">// let len = 1;</span></span><br><span class="line">    <span class="comment">// for(let i = 1; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     if(nums[i] &gt; nums[i-1]) &#123;</span></span><br><span class="line">    <span class="comment">//         len++;   </span></span><br><span class="line">    <span class="comment">//     &#125;else &#123;</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//         len = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     max = max &gt; len ? max : len;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return max;</span></span><br><span class="line">    <span class="comment">//方法二：动态规划</span></span><br><span class="line">    <span class="type">let</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">let</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(nums.length).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = result &gt; dp[i] ? result : dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-最长重复子数组"><a href="#21-最长重复子数组" class="headerlink" title="21. 最长重复子数组"></a>21. 最长重复子数组</h3><ul>
<li>dp采用二维数组。注意初始化以及结尾的表达</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路：有两个数组，采用动态规划，其实情况的列举就是枚举数组A和数组B的所有组合情况</span></span><br><span class="line"><span class="comment"> *       所以可以采用二维dp数组，dp[i][j]</span></span><br><span class="line"><span class="comment"> *       i表示数组A的索引，j表示数组B的索引。以此构造状态转移公式</span></span><br><span class="line"><span class="comment"> * 注意：这里dp[i][j]表示以i结尾的数组A和以j结尾的数据B的最长重复子数组的长度</span></span><br><span class="line"><span class="comment"> *       这里i和j表示一定在重复子数组中（重点）</span></span><br><span class="line"><span class="comment"> * 递推公式：如果A[i] == B[j] 则dp[i][j] = dp[i-1][j-1] + 1。否则为0</span></span><br><span class="line"><span class="comment"> * 初始化：由于不好初始化，所以改变dp[i][j]的含义</span></span><br><span class="line"><span class="comment"> *        dp[i][j]表示以i-1结尾的数组A和以j-1结尾的数组B的最长重复子数组长度</span></span><br><span class="line"><span class="comment"> *        所以i和j的初始化从1开始，不是从0开始</span></span><br><span class="line"><span class="comment"> *        dp[0][j]和dp[i][0]=0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findLength = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums1.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(nums2.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = max &gt; dp[i][j] ? max : dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="22-最长公共子序列"><a href="#22-最长公共子序列" class="headerlink" title="22. 最长公共子序列"></a>22. 最长公共子序列</h3><ul>
<li>不要求连续，dp数组不表示结尾字符。注意递推表达式</li>
<li>还有返回值一定是<code>dp[a.length][b.length]</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和最长重复子数组（连续）不一样，本题子序列不要求连续。</span></span><br><span class="line"><span class="comment"> * 所以dp[i][j]不只是从dp[i-1][j-1]推导出来。而是可以又dp[i][j-1]和dp[i-1][j]推到</span></span><br><span class="line"><span class="comment"> * dp[i][j]表示从0到i的数组A 和从0到j的数组b的子序列长度（注意重点，不要求结尾字符）</span></span><br><span class="line"><span class="comment"> * 若A[i] == B[j]， 则dp[i][j] = dp[i-1][j-1] + 1。</span></span><br><span class="line"><span class="comment"> * 若A[i] != B[j], 则max(dp[i-1][j], dp[i[j-1]])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [m, n] = [text1.<span class="property">length</span>, text2.<span class="property">length</span>];</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i-<span class="number">1</span>] === text2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="23-最大子数组和"><a href="#23-最大子数组和" class="headerlink" title="23. 最大子数组和"></a>23. 最大子数组和</h3><ul>
<li>注意递推表达式，是拿自身和dp[i-1] + nums[i]相比</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i]表示以i-1结尾的最大子数组和</span></span><br><span class="line"><span class="comment"> * dp[i] = Max(nums[i],dp[i-1] + nums[i])</span></span><br><span class="line"><span class="comment"> * 注意递推表达式，是拿自身和dp[i-1] + nums[i]相比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i-<span class="number">1</span>], dp[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>]);</span><br><span class="line">        max = max &gt; dp[i] ? max : dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="24-判断子序列"><a href="#24-判断子序列" class="headerlink" title="24. 判断子序列"></a>24. 判断子序列</h3><ul>
<li>编辑距离，其实就和求两个字符串的最长公共子序列一样。只是递推公式有点不同</li>
<li><strong>和最长公共子序列的区别：</strong><ul>
<li><strong>最长公共子序列，<code>s</code>和<code>t</code>都删除</strong>。<code>若A[i] != B[j], 则max(dp[i-1][j], dp[i[j-1]])</code></li>
<li>**而本题，考虑的是<code>s</code>是否是<code>t</code>的子序列，只删除<code>t</code>不删除<code>s</code>**。<code>dp[i][j] = dp[i][j-1]</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法三：动态规划，编辑距离。其实就是判断s和t的最长公共子序列，</span></span><br><span class="line"><span class="comment"> * 如果最长公共子序列的长度等于s的长度，说明s是t的子序列</span></span><br><span class="line"><span class="comment"> * dp[i][j]表示从0到i的s和从0到j的t的最长公共子序列的长度</span></span><br><span class="line"><span class="comment"> * 如果s[i] === t[j] , 则dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment"> * 否则， dp[i][j] = dp[i][j-1]（注意和求公共子序列的不同，这里只考虑了j-1的情况）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSubsequence = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">//方法一：判断index是否是递增</span></span><br><span class="line">    <span class="comment">// let index = -1;</span></span><br><span class="line">    <span class="comment">// for(let i = 0; i &lt; s.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     let j = t.substring(index + 1).indexOf(s[i]);</span></span><br><span class="line">    <span class="comment">//     if(j === -1) return false;</span></span><br><span class="line">    <span class="comment">//     if(j + index + 1 &lt;= index) return false;</span></span><br><span class="line">    <span class="comment">//     index = j + index + 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return true;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：双指针判断s的元素是否出现在t中</span></span><br><span class="line">    <span class="comment">// let j = 0;</span></span><br><span class="line">    <span class="comment">// for(let i = 0; i &lt; t.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     if(s[j] === t[i]) &#123;</span></span><br><span class="line">    <span class="comment">//         j++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// if(j === s.length) return true;</span></span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法三：动态规划，编辑距离。</span></span><br><span class="line">    <span class="comment">//其实就是判断s和t的最长公共子序列，如果最长公共子序列的长度等于s的长度，说明s是t的子序列</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(t.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= t.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i-<span class="number">1</span>] === t[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>];	<span class="comment">//这里和最长公共子序列不同，因为只删除t，不删除s</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[s.<span class="property">length</span>][t.<span class="property">length</span>] == s.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="25-不同子序列"><a href="#25-不同子序列" class="headerlink" title="25. 不同子序列"></a>25. 不同子序列</h3><ul>
<li><code>dp[i][j]</code>表示从<code>0</code>到<code>i</code>的<code>s</code>中，出现以<code>j</code>结尾的<code>t</code>的次数</li>
<li>注意初始化</li>
<li>注意删除的是<code>s</code>，不删除<code>t</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i][j]表示从0到i的s中，出现以j结尾的t的次数</span></span><br><span class="line"><span class="comment"> * 如果s[i] == t[j], dp[i][j] = dp[i-1][j-1] +  dp[i-1][j], </span></span><br><span class="line"><span class="comment"> *     考虑用s[i]来匹配t[j]，则dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment"> *     不考虑用s[i]匹配t[j], 则dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment"> *      注意是相加哦！</span></span><br><span class="line"><span class="comment"> * 否则dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 初始化dp[0][0] = 1</span></span><br><span class="line"><span class="comment"> * dp[i][0] = 1  表示从s中随便删除元素，出现空字符串的个数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意点：这题考虑的是s中有多少个t，所以是对s进行删除匹配，i-1但是j不减1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numDistinct = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(t.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= t.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i-<span class="number">1</span>] === t[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="property">length</span>][t.<span class="property">length</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="26-编辑距离"><a href="#26-编辑距离" class="headerlink" title="26. 编辑距离"></a>26. 编辑距离</h3><ul>
<li>注意这里的删除、替换操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i][j]表示以i结尾的A和以j结尾的B，最小的编辑距离</span></span><br><span class="line"><span class="comment"> * 如果A[i] == B[j], dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment"> * 如果A[i] != B[j],</span></span><br><span class="line"><span class="comment"> *     删除A[i], dp[i-1][j] + 1</span></span><br><span class="line"><span class="comment"> *     删除B[i], dp[i][j-1] + 1</span></span><br><span class="line"><span class="comment"> *     替换A[i]， dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment"> *     则，dp[i][j] = min(dp[i-1][j], dp[i][j-1],dp[i-1][j-1]  ) + 1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 初始化： dp[i][0] = i。表示从0到i-1的A与空字符串的最小编辑距离（注意初始化）</span></span><br><span class="line"><span class="comment"> *         dp[0][j] = j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="keyword">function</span>(<span class="params">word1, word2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(word1.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(word2.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word1.<span class="property">length</span> ; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= word2.<span class="property">length</span> ; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= word1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= word2.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i-<span class="number">1</span>] === word2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.<span class="property">length</span>][word2.<span class="property">length</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="子序列、子数组总结"><a href="#子序列、子数组总结" class="headerlink" title="子序列、子数组总结"></a>子序列、子数组总结</h3><ul>
<li>子序列的dp数组一般表示从<code>0</code>到<code>i</code></li>
<li>子数组的dp数组一般表示以<code>i</code>结尾</li>
<li>注意点：<ul>
<li>子序列问题，<code>dp[i][j]</code>表示的<code>i-1</code>和<code>j-1</code>位置是否相同。所以<code>i</code>和<code>j</code>是从1开始遍历的<ul>
<li><code>dp[i][j]表示从0到i的数组A 和从0到j的数组b的子序列长度（注意重点，不要求结尾字符）</code></li>
<li><code>若A[i] == B[j]， 则dp[i][j] = dp[i-1][j-1] + 1。</code></li>
<li><code>若A[i] != B[j], 则max(dp[i-1][j], dp[i[j-1]])</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h3><ul>
<li><p>注意子串和子序列的不同点，一个连续一个不连续，最终递推表达式有所不同</p>
<blockquote>
<p>若<code>i + 1 &lt; j</code>，则判断<code>dp[i][j]</code>是否为回文子串，等于判断<code>dp[i + 1] [j - 1]</code>是否为回文子串</p>
<p>如果不等的话，分别判断<code>i</code>和<code>j</code>的加入对序列有没有影响 则<code>dp[i] [j] = max(dp[i] [j-1], dp[i+1] [j])</code></p>
</blockquote>
</li>
<li><p>给定一个字符串，计算这个字符串中有多少回文子串</p>
</li>
<li><p>动态规划：<code>dp</code>数组，<code>dp[i][j]</code>:表示区间<code>i</code>到<code>j</code>是否为回文子串(左闭右闭区间)</p>
<ul>
<li>递推公式：<ul>
<li>判断<code>s[i]</code>是否等于<code>s[j]</code>。如果相等：<ul>
<li>若<code>i == j</code>, 则是回文子串</li>
<li>若<code>i + 1 == j</code>, 则是回文子串</li>
<li>若<code>i + 1 &lt; j</code>，则判断<code>dp[i][j]</code>是否为回文子串，等于判断dp[i + 1] [j - 1]是否为回文子串</li>
</ul>
</li>
</ul>
</li>
<li>注意点：需要从下往上，从左往右计算，</li>
</ul>
</li>
<li><p>中心扩散：找中心，往两边扩散判断是否对称</p>
<ul>
<li>遍历中心点有两种情况：</li>
</ul>
<ol>
<li><p>一个元素作为中心点</p>
</li>
<li><p>两个元素作为中心点</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里dp[i][j]不能表示回文子串的个数，只能表示是否为回文子串</span></span><br><span class="line"><span class="comment"> * 方法二：动态规划</span></span><br><span class="line"><span class="comment"> * dp数组，dp[i][j]:表示区间i到j是否为回文子串(左闭右闭区间)</span></span><br><span class="line"><span class="comment"> * 递推公式：</span></span><br><span class="line"><span class="comment"> *  判断s[i]是否等于s[j]。如果相等：</span></span><br><span class="line"><span class="comment"> * 若i == j, 则是回文子串</span></span><br><span class="line"><span class="comment"> * 若i + 1 == j, 则是回文子串</span></span><br><span class="line"><span class="comment"> * 若i + 1 &lt; j，则判断dp[i][j]是否为回文子串，等于判断dp[i + 1][j - 1]是否为回文子串</span></span><br><span class="line"><span class="comment"> * 注意点：需要从下往上，从左往右计算，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countSubstrings = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>));</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = s.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从下往上计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i; j &lt; s.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == i) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == i + <span class="number">1</span> &amp;&amp; s[j] == s[i]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; s[j] == s[i]) dp[i][j] =dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>  dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] == <span class="number">1</span>) count++;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dp[&quot;</span> + i + <span class="string">&quot;]&quot;</span>+ <span class="string">&quot;dp[&quot;</span>+j+<span class="string">&quot;]&quot;</span>+dp[i][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> countSubstrings = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * len - <span class="number">1</span>; i++) &#123;<span class="comment">//有2*len -1种中心点的情况</span></span><br><span class="line">        <span class="keyword">var</span> left = <span class="title class_">Math</span>.<span class="title function_">floor</span>(i/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> right = left + i % <span class="number">2</span>;   <span class="comment">//right或等于left ,或等于left+ 1</span></span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; len &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            left--;</span><br><span class="line">            right++;<span class="comment">//从中心往两边扩散</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><ul>
<li><p>回文子序列：不要求连续。</p>
</li>
<li><p>回文子串：要求连续</p>
</li>
<li><p><code>dp[i] [j]</code>表示从i到j的最长回文子序列长度</p>
</li>
<li><p><code>如果s[i]==s[j]，则dp[i] [j] = dp[i+1] [j-1] + 2;</code></p>
</li>
<li><p>如果不等的话，分别判断<code>i</code>和<code>j</code>的加入对序列有没有影响 则<code>dp[i] [j] = max(dp[i] [j-1], dp[i+1] [j])</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">longestPalindromeSubseq</span> = (<span class="params">s</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> strLen = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(strLen), <span class="function">() =&gt;</span> <span class="title class_">Array</span>(strLen).<span class="title function_">fill</span>(<span class="number">0</span>));<span class="comment">//初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = strLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从下往上，从左往右遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; strLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] === s[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;<span class="comment">//由于初始化为0，这里也就包含了i+1 == j的情况</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);<span class="comment">//ij分开讨论</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][strLen - <span class="number">1</span>];<span class="comment">//最长回文子序列的取值范围</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2024/06/09/leetcode/_动态规划思维导图_青.jpg" style="zoom: 200%;"></li>
</ul>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul>
<li>贪心算法没有固定的解题套路，基本上是局部最优可以推出全局最优</li>
</ul>
<h3 id="1-分发小饼干"><a href="#1-分发小饼干" class="headerlink" title="1. 分发小饼干"></a>1. 分发小饼干</h3><ul>
<li>把最大的饼干喂给胃口最大的小朋友，这样浪费的才少，是局部最优解</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对g和s进行排序，遍历找寻满足条件的对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findContentChildren = <span class="keyword">function</span>(<span class="params">g, s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    g.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    s.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> j = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = g.<span class="property">length</span>-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i] &lt;= s[j]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-摆动序列"><a href="#2-摆动序列" class="headerlink" title="2. 摆动序列"></a>2. 摆动序列</h3><ul>
<li><p>可以用动态规划。注意每个点有两种情况，即两种状态，所以每个点的dp数组，是一个二维数组，表示两种状态</p>
</li>
<li><p>也可以用贪心算法，删除掉单调坡上的点（不包含端点），需要考虑平坡的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以类比求最长递增子序列。但是本题，当前值有可能比前一个数小，也有可能比前一个数大。</span></span><br><span class="line"><span class="comment"> * 即有两种状态，所以dp数组是二维数组</span></span><br><span class="line"><span class="comment"> * dp[i][0]: 表示以i结尾的数，作为山峰时的最长摆动序列的长度</span></span><br><span class="line"><span class="comment"> * dp[i][1]: 表示以i结尾的数，作为山谷时的最长摆动序列的长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 遍历小于i的数，如果nums[j] &lt; nums[i], 则dp[i][0] = max(dp[i][0], dp[j][1] + 1)</span></span><br><span class="line"><span class="comment"> * 遍历小于i的数，如果nums[j] &gt; nums[i], 则dp[i][1] = max(dp[i][1], dp[j][0] + 1)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 初始化均为1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 方法二：贪心算法</span></span><br><span class="line"><span class="comment"> * 局部最优：删除单调坡上的点，就可以达到全局最优，摆动序列最长</span></span><br><span class="line"><span class="comment"> * preDiff &lt;= 0 &amp;&amp; curDiff &gt;0  或者 preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0 </span></span><br><span class="line"><span class="comment"> * 注意特殊情况 1 2 2 1、 1 2 2 3。 preDiff的更新需要在坡度发生变化的时候更新</span></span><br><span class="line"><span class="comment"> * 只有两个元素的情况，直接判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> wiggleMaxLength = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">//方法一：动态规划</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>).<span class="title function_">fill</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i][<span class="number">0</span>], dp[j][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i][<span class="number">1</span>], dp[j][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[nums.<span class="property">length</span> - <span class="number">1</span>][<span class="number">0</span>], dp[nums.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：贪心算法</span></span><br><span class="line">    <span class="keyword">let</span> preDiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> curDiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; nums[<span class="number">1</span>] !== nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        curDiff = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span> || preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            preDiff = curDiff  <span class="comment">//只有出现摆动了，才更新preDiff，避免单调坡上出现平坡</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-最大子数组和"><a href="#3-最大子数组和" class="headerlink" title="3. 最大子数组和"></a>3. 最大子数组和</h3><ul>
<li>可用动态规划</li>
<li>也可用贪心。<strong>当连续和出现负数的时候</strong>，立即放弃。从下一个元素开始重新计算连续和。（因为负数的连续和会拖累整体）</li>
<li>动态规划的空间复杂度大于贪心算法的空间复杂度</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：贪心算法</span></span><br><span class="line">    <span class="keyword">let</span> result = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        count += nums[i];</span><br><span class="line">        result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, count);</span><br><span class="line">        <span class="keyword">if</span>(count &lt; <span class="number">0</span>) count = <span class="number">0</span>;	<span class="comment">//连续和为负数了。从下一个数开始计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h3 id="4-买卖股票的最佳时机2"><a href="#4-买卖股票的最佳时机2" class="headerlink" title="4. 买卖股票的最佳时机2"></a>4. 买卖股票的最佳时机2</h3><ul>
<li>理解利润拆分是本题的关键点。把整体的利润拆分成每天的利润</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：贪心算法</span></span><br><span class="line"><span class="comment">//把利润分解为以每天为单位的维度，每天都会获得利润。详见代码随想录</span></span><br><span class="line"><span class="comment">//那么每天获得的正利润就是最终的最大利润。而正利润的区间就是买卖股票的区间</span></span><br><span class="line"><span class="comment">//局部最优：每天获得正利润。全局最优：最终获得最大利润</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result += <span class="title class_">Math</span>.<span class="title function_">max</span>(prices[i] - prices[i-<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<h3 id="5-跳跃游戏"><a href="#5-跳跃游戏" class="headerlink" title="5. 跳跃游戏"></a>5. 跳跃游戏</h3><ul>
<li>可以用动态规划</li>
<li>也可贪心，记录步数可以覆盖的范围即可。如果最后覆盖范围超过了最后一个数，就可以。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 能否到达最后一个位置,取决于nums[i] &gt;= j - i的位置i，dp[i]是否能达到</span></span><br><span class="line"><span class="comment"> * dp[i]表示位置i是否能到达</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">//方法一：动态规划</span></span><br><span class="line">    <span class="comment">// var dp = new Array(nums.length).fill(false);</span></span><br><span class="line">    <span class="comment">// dp[0] = true;</span></span><br><span class="line">    <span class="comment">// for(let i = 1; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for(let j = 0; j &lt; i; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         if(nums[j] &gt;= i - j) &#123;</span></span><br><span class="line">    <span class="comment">//             dp[i] = dp[j];</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return dp[nums.length-1];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：贪心算法。记录步数可以覆盖的范围即可。如果最后覆盖范围超过了最后一个数，就可以</span></span><br><span class="line">    <span class="keyword">let</span> range = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        range = <span class="title class_">Math</span>.<span class="title function_">max</span>(i + nums[i], range);</span><br><span class="line">        <span class="keyword">if</span>(range &lt; i+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(range &gt;= nums.<span class="property">length</span>-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-跳跃游戏2"><a href="#6-跳跃游戏2" class="headerlink" title="6. 跳跃游戏2"></a>6. 跳跃游戏2</h3><ul>
<li>贪心算法：需统计两个覆盖范围，当前这一步的最大覆盖范围和下一步的最大覆盖范围。<ul>
<li>以最小的步数增加最大覆盖范围，知道覆盖范围覆盖到了终点</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jump = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> nextIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> steps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nextIndex = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i] + i, nextIndex)</span><br><span class="line">        <span class="keyword">if</span>(i === curIndex) &#123;</span><br><span class="line">            curIndex = nextIndex</span><br><span class="line">            steps++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-k次取反后最大化数组和"><a href="#7-k次取反后最大化数组和" class="headerlink" title="7. k次取反后最大化数组和"></a>7. k次取反后最大化数组和</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己的做法，思路复杂，没有认真思考贪心的思想</span></span><br><span class="line"><span class="comment"> * 尽可能的将负数转成正数</span></span><br><span class="line"><span class="comment"> * 负数个数m，</span></span><br><span class="line"><span class="comment"> * 如果m &lt; k, 把所有负数转正，如果k-m是2的倍数，则最大和就是负数转正后的数组和sum。如果k-m是奇数，则最大和就是sum减去2倍的最小正数</span></span><br><span class="line"><span class="comment"> * 如果m == k, 则把所有负数转正，则最大和就是负数转正后的数组和sum</span></span><br><span class="line"><span class="comment"> * 如果m &gt; k, 则将负数按照从小到大，一次转正，求数组和即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 方法二：贪心</span></span><br><span class="line"><span class="comment"> * 局部最优推到全局最优，如何使反转数之后，和最大。</span></span><br><span class="line"><span class="comment"> * 自然是先反转绝对值最大的负数（这里是局部最优）</span></span><br><span class="line"><span class="comment"> * 如果负数反转完了，k还没完，那么自然是反转绝对值最小的正数</span></span><br><span class="line"><span class="comment"> * （注意这里，所有的数都变成了正数。再次用到局部最优）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以本题先按照绝对值从大到小的顺序对数组进行排序（注意是绝对值）</span></span><br><span class="line"><span class="comment"> * 然后依次遍历，减小k就行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> largestSumAfterKNegations = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="comment">//贪心算法</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(b) - <span class="title class_">Math</span>.<span class="title function_">abs</span>(a));<span class="comment">//按照绝对值从大到小排序</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            k--;    <span class="comment">//遇到负数，消耗k</span></span><br><span class="line">            nums[i] = -nums[i]; <span class="comment">//并把负数变成变成正数</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i]; <span class="comment">//计算sum</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k != <span class="number">0</span> &amp;&amp; k%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        sum -= <span class="number">2</span> * nums[nums.<span class="property">length</span>-<span class="number">1</span>];<span class="comment">//减去两倍的，因为之前加过一次，注意这里数组已经全部变成正数了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-加油站"><a href="#8-加油站" class="headerlink" title="8. 加油站"></a>8. 加油站</h3><ul>
<li>局部最优：确保每一个站点的<code>gas[i]</code>大于<code>cost[i]</code>，</li>
<li>整体最优：如果每个站点的剩油量rest[i]的总和小于0了，那么一定不能跑完全程。以0到<code>i</code>之间的任何位置为开始点的话，一定不行。那么下一次就从<code>i+1</code>的位置开始</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目确保可以跑完一圈，一定可以找到一个入口（说错了）</span></span><br><span class="line"><span class="comment"> * 方法一：暴力解法，每一个点开始逐步寻找，</span></span><br><span class="line"><span class="comment"> * 方法二：贪心。gas[i]-cost[i]是每个站点跑完之后的剩油量，</span></span><br><span class="line"><span class="comment"> *        剩油量必须大于0，才可以跑完。</span></span><br><span class="line"><span class="comment"> *        如果某个站点的剩油量rest[i]小于0了，那么一定不能跑完全程</span></span><br><span class="line"><span class="comment"> *        所以以0到i之间的任何位置为开始点的话，一定不行</span></span><br><span class="line"><span class="comment"> *        那么下一次就从i+1的位置开始</span></span><br><span class="line"><span class="comment"> *        注意：当rest[i]的总和小于0的时候，就是返回-1,一定找不到入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canCompleteCircuit = <span class="keyword">function</span>(<span class="params">gas, cost</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> rest = <span class="keyword">new</span> <span class="title class_">Array</span>(gas.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> totalSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gas.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        totalSum += gas[i] - cost[i];</span><br><span class="line">        rest[i] = gas[i] - cost[i];</span><br><span class="line">        sum += rest[i];    </span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            start = i + <span class="number">1</span>; <span class="comment">//入口一定在[i+1::]区间中</span></span><br><span class="line">            sum = <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//找不到的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> start;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-分发糖果"><a href="#9-分发糖果" class="headerlink" title="9. 分发糖果"></a>9. 分发糖果</h3><ul>
<li><p>采用了两次贪心的策略：</p>
<ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<p>这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己的思路：考虑找到最小评分的孩子，然后从两边发散遍历。同时考虑左右两边的情况。无法进行传递。方法不对</span></span><br><span class="line"><span class="comment"> * 考虑使用贪心的算法</span></span><br><span class="line"><span class="comment"> * 评分高的孩子需要比左右两边的糖果数多，左右两边有两种情况，</span></span><br><span class="line"><span class="comment"> * 考虑先考虑左边，再考虑右边（即先保证比左边的孩子糖果数多，再保证比右边孩子的糖果数多）</span></span><br><span class="line"><span class="comment"> * 两种遍历，一是从前往后遍历，二是从后往前遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> candy = <span class="keyword">function</span>(<span class="params">ratings</span>) &#123;</span><br><span class="line">    <span class="comment">//贪心算法，局部最优-&gt;整体最优 </span></span><br><span class="line">    <span class="keyword">let</span> candyArr = <span class="keyword">new</span> <span class="title class_">Array</span>(ratings.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; ratings.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            candyArr[i] = candyArr[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = ratings.<span class="property">length</span>-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            candyArr[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(candyArr[i+<span class="number">1</span>] + <span class="number">1</span>, candyArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candyArr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">pre, cur</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pre + cur;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-根据身高重建队列"><a href="#10-根据身高重建队列" class="headerlink" title="10. 根据身高重建队列"></a>10. 根据身高重建队列</h3><ul>
<li>两个维度，分开考虑。先按身高进行排序。再按k进行插入</li>
<li>注意splice函数的应用（在数组特定位置插入元素）</li>
<li>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性。全局最优：最后都做完插入操作，整个队列满足题目队列属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路完全想不到，要求身高高的在前面，要求前面身高高于自己的个数等于自己的k</span></span><br><span class="line"><span class="comment"> * 有两个维度，一个是身高h，一个是个数k</span></span><br><span class="line"><span class="comment"> * 和分发糖果一样，确定一个维度后考虑另外一个维度</span></span><br><span class="line"><span class="comment"> * 先确定h维度，将身高高的排在前面（如果身高相同 ，将k小的排在前面）</span></span><br><span class="line"><span class="comment"> * 在确定k维度，按照k的数值，进行插入操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reconstructQueue = <span class="keyword">function</span>(<span class="params">people</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    people.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];<span class="comment">//如果身高相同 ，将k小的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];     <span class="comment">//身高高的排在前面</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; people.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//参数：插入的位置，删除元素的个数，替代元素的值</span></span><br><span class="line">        queue.<span class="title function_">splice</span>(people[i][<span class="number">1</span>], <span class="number">0</span>, people[i]);<span class="comment">//注意splice函数的应用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-用最少数量的箭引爆气球"><a href="#11-用最少数量的箭引爆气球" class="headerlink" title="11. 用最少数量的箭引爆气球"></a>11. 用最少数量的箭引爆气球</h3><ul>
<li>问题转化成，寻找重叠气球右边边界的最小值，(当前弓箭的覆盖范围)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完全没思路</span></span><br><span class="line"><span class="comment"> * 先对区间按照初始位置进行排序</span></span><br><span class="line"><span class="comment"> * 如何确定是否要射弓箭？重叠气球中右边边界的最小值之前的区间需要一个弓箭</span></span><br><span class="line"><span class="comment"> * 那么问题转化成，寻找重叠气球右边边界的最小值，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinArrowShots = <span class="keyword">function</span>(<span class="params">points</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(points.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    points.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; points.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i-<span class="number">1</span>][<span class="number">1</span>] &lt; points[i][<span class="number">0</span>]) &#123;<span class="comment">//不挨着的话，那么就需要再来一支弓箭</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//有重叠的话，说明当前弓箭的覆盖范围可以扩大了，找到重叠区间，最小右边界即可</span></span><br><span class="line">            points[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">min</span>(points[i-<span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-无重叠区间"><a href="#12-无重叠区间" class="headerlink" title="12. 无重叠区间"></a>12. 无重叠区间</h3><ul>
<li>本题和弓箭那一个基本一样，弓箭是求不相交区间的个数，而本题是求重叠区间的个数。（用区间总数减去弓箭数量就是本题的答案）</li>
<li>也可以直接求要删除的区间数量，按顺序排列，遇到重叠的就移除</li>
<li><strong>思考：</strong>本题和弓箭范围题一样，思考方式都是考虑当前区间的范围，通过判断范围来确定下一步的操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 只要出现重叠的情况，一定是要有区间要移开的</span></span><br><span class="line"><span class="comment">  * 一个区间的end，表示该end的范围内，不可以出现第二个区间，就是要移除区间</span></span><br><span class="line"><span class="comment">  * 要移的区间是区间范围比当前范围大的区间，选end最大的而移动，因为end越大，它覆盖的范围越广</span></span><br><span class="line"><span class="comment">  * 移掉end范围大的，能够达到局部最优</span></span><br><span class="line"><span class="comment">  * 只要下一个区间的start小于当前的end，那么移动数量加一，，同时更新end的值</span></span><br><span class="line"><span class="comment">  * end取两个区间end的最大值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> eraseOverlapIntervals = <span class="keyword">function</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    intervals.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; intervals.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; end) &#123;<span class="comment">//有重叠,result++,更新end的范围</span></span><br><span class="line">            result++;</span><br><span class="line">            end = <span class="title class_">Math</span>.<span class="title function_">min</span>(intervals[i][<span class="number">1</span>], end);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//无重叠，不需要移除区间，更新end的范围</span></span><br><span class="line">            end = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本题和弓箭那一个基本一样，</span></span><br><span class="line"><span class="comment"> * 弓箭是求不相交区间的个数，而本题是求重叠区间的个数</span></span><br><span class="line"><span class="comment"> * （用区间总数减去弓箭数量就是本题的答案）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 按顺序排列，遇到重叠的就移除</span></span><br><span class="line"><span class="comment"> * （移除哪一个需要判断，比如区间[1,100]和[80, 90]需要移除100的那个）</span></span><br><span class="line"><span class="comment"> * 代码中移除，体现在math.min函数中为intervals[i][1]赋值的那一个语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> eraseOverlapIntervals = <span class="keyword">function</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">    intervals.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; intervals.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i-<span class="number">1</span>][<span class="number">1</span>]) &#123;<span class="comment">//出现重叠的情况，一定要移除即result必然增加</span></span><br><span class="line">            result++;</span><br><span class="line">            <span class="comment">//但是移除哪一个需要判断，如果前一个覆盖范围广，删除前一个，end取后一个</span></span><br><span class="line">            intervals[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">min</span>(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-合并区间"><a href="#13-合并区间" class="headerlink" title="13. 合并区间"></a>13. 合并区间</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(intervals.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    intervals.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    result.<span class="title function_">push</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; intervals.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= result[result.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>]) &#123;<span class="comment">//有重叠，更新result中的数据</span></span><br><span class="line">            result[result.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(intervals[i][<span class="number">1</span>], result[result.<span class="property">length</span> - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//无重叠，直接加入result</span></span><br><span class="line">            result.<span class="title function_">push</span>(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">    intervals.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">let</span> pre = intervals[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intervals.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= pre[<span class="number">1</span>]) &#123;<span class="comment">//重叠</span></span><br><span class="line">            pre[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//无重叠</span></span><br><span class="line">            result.<span class="title function_">push</span>(pre);</span><br><span class="line">            pre = intervals[i]<span class="comment">//更新pre，pre记录当前要加入的区间</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">push</span>(pre);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="14-单调递增的数字"><a href="#14-单调递增的数字" class="headerlink" title="14. 单调递增的数字"></a>14. 单调递增的数字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路巧妙：直接在原字符串上操作便可得到最大的递增数字</span></span><br><span class="line"><span class="comment"> * 通过比较n[i-1]和n[i]的大小，</span></span><br><span class="line"><span class="comment"> * 当n[i-1]小于n[i]的时，把n[i-1]--,并把n[i]置为9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> monotoneIncreasingDigits = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = n.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//数字转成字符串转成数组</span></span><br><span class="line">    <span class="keyword">let</span> flag = num.<span class="property">length</span>; <span class="comment">//flag用于记录9开始的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = num.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i-<span class="number">1</span>] &gt; num[i]) &#123;</span><br><span class="line">            num[i-<span class="number">1</span>]--;</span><br><span class="line">            flag = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = flag; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        num[i] = <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(num.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));<span class="comment">//数组转成字符串转成数字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="16-监控二叉树"><a href="#16-监控二叉树" class="headerlink" title="16.监控二叉树"></a>16.监控二叉树</h3><ul>
<li>本题设计到贪心、二叉树上的状态转移（利用递归的返回值）、设置每个节点的状态、采用后序遍历进行二叉树的从下网上的遍历</li>
<li>递归遇到空节点时，将空节点的状态置为有覆盖，返回2</li>
<li>最后还需判断根节点的状态，如果没有覆盖，则result++</li>
<li>难点：每个节点状态的确定、递归返回值的应用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.贪心：二叉树从下往上遍历，对于叶子节点覆盖的越多，摄像头用的越少</span></span><br><span class="line"><span class="comment"> *          从下往上放摄像头，就是局部最优，最后便能达到整体最优</span></span><br><span class="line"><span class="comment"> *          注意：从下往上遍历，采用后序遍历</span></span><br><span class="line"><span class="comment"> * 2.每个节点有三种状态：</span></span><br><span class="line"><span class="comment">*         0是无覆盖</span></span><br><span class="line"><span class="comment">*         1是有摄像头</span></span><br><span class="line"><span class="comment">*         2是有覆盖     (注意摄像头肯有覆盖是分开的)</span></span><br><span class="line"><span class="comment"> * 3.在二叉树上进行状态推导（如何确定当前节点是否要放摄像头）</span></span><br><span class="line"><span class="comment"> *     递归的返回值，表示当前节点所处的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minCameraCover = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> myMin = <span class="keyword">function</span>(<span class="params">cur</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//空节点的状态是有覆盖（这样就不会给叶子放摄像头）</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="title function_">myMin</span>(cur.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">let</span> right = <span class="title function_">myMin</span>(cur.<span class="property">right</span>);<span class="comment">//遍历左右子树</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//判断左右子树节点的状态</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//左右节点是有覆盖，本节点是无覆盖</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//左右节点至少有一个是无覆盖的，本节点是有摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span> || right == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//左右节点至少有一个是有摄像头的</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">myMin</span>(root) == <span class="number">0</span>) result++;<span class="comment">//还需判断根节点的状态，如果没有覆盖，则result++</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="主持人调度问题"><a href="#主持人调度问题" class="headerlink" title="主持人调度问题"></a>主持人调度问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只要有重叠区间，就需要增加一个主持人，没有重叠就不加，</span></span><br><span class="line"><span class="comment"> * 和力扣上，删除最少区间，得到无重叠区间的个数这道题一样</span></span><br><span class="line"><span class="comment"> * 更新end的时候取最小的</span></span><br><span class="line"><span class="comment"> * 当有重叠的时候，不是单纯的就增加一个主持人，需要判断以往增加的主持人的end有没有当前区间的start的，如果有的话，就不用增加主持人，同时更新该主持人的end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">minmumNumberOfHost</span>(<span class="params"> n ,  startEnd </span>) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">// startEnd.sort((a, b) =&gt; a[0] - b[0]);</span></span><br><span class="line">    <span class="comment">// let result = [];</span></span><br><span class="line">    <span class="comment">// result.push(startEnd[0][1]);</span></span><br><span class="line">    <span class="comment">// let end = startEnd[0][1];</span></span><br><span class="line">    <span class="comment">// for(let i = 1; i &lt; startEnd.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     if(startEnd[i][0] &lt; end) &#123;//有重叠</span></span><br><span class="line">    <span class="comment">//         let item = result.filter((item, index, arr) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//             return item &lt;= startEnd[i][0];</span></span><br><span class="line">    <span class="comment">//         &#125;)</span></span><br><span class="line">    <span class="comment">//         let index = item.map((nums) =&gt; result.indexOf(nums));</span></span><br><span class="line">    <span class="comment">//         if(index.length !== 0) &#123;</span></span><br><span class="line">    <span class="comment">//             result[index[0]] = startEnd[i][1];</span></span><br><span class="line">    <span class="comment">//         &#125;else &#123;//需要增加主持人</span></span><br><span class="line">                </span><br><span class="line">    <span class="comment">//             end = Math.min(end, startEnd[i][1]);</span></span><br><span class="line">    <span class="comment">//             result.push(end);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="comment">//     &#125;else &#123;//无重叠</span></span><br><span class="line">    <span class="comment">//         end = startEnd[i][1];</span></span><br><span class="line">    <span class="comment">//         result[result.length - 1] = end;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return result.length;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不知道怎么写的，把开始时间和结束时间分开排序，判断下一个区间的开始时间和上一个区间的结束时间</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="title class_">Array</span>(startEnd.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">let</span> end = <span class="keyword">new</span> <span class="title class_">Array</span>(startEnd.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        start[i] = startEnd[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = startEnd[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    start.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    end.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start[i] &gt;= end[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h3><ol>
<li><p>在 CSS 中，同一个颜色有多种颜色表示方法，最常用的是 HEX 和 RGB，比如下面的元组表示同样的颜色：</p>
<p>红色：#ff0000 等价于 rgb(255, 0, 0)<br>绿色：#00ff00 等价于 rgb(0, 255, 0)<br>蓝色：#0000ff 等价于 rgb(0, 0, 255)<br>请实现一个函数，如果传入的是 HEX 颜色格式，返回 RGB 格式。如果是 RGB 颜色格式，返回 HEX 颜色格式。如果入参非法（表示颜色无法在 CSS 中使用），则扔出异常。</p>
<img src="/2024/06/09/leetcode/面题01.jpg" style="zoom:50%;">
</li>
<li><p>对一个给定的时间字符串（格式为 “hh:mm”），时针和分针所成的角度是确定的，比如 “03:00” 为 90 度，”06:00” 为 180 度。</p>
<p>现在需要你实现一个算法，计算入参给定时间下时针和分针所成的内角角度（0 &lt;&#x3D; deg &lt;&#x3D; 180）。如果计算的结果不是整数，请给出整数部分。</p>
<p>同时，请给出你会验证的用例列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">caclu</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = time.<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> angleH = arr[<span class="number">0</span>]%<span class="number">12</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> angleM = arr[<span class="number">1</span>] * <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(angleH - angleM) &gt; <span class="number">180</span>) &#123;</span><br><span class="line">        result = <span class="number">360</span> - <span class="title class_">Math</span>.<span class="title function_">abs</span>(angleH - angleM);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="title class_">Math</span>.<span class="title function_">abs</span>(angleH - angleM)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1. 快速排序"></a>1. 快速排序</h3><ul>
<li>快速排序，选择一个分割点，使得左边的元素均小于分割点的元素，右边的元素均大于分割点的元素。再使用递归函数对分割点两边的序列重新排序</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 快速排序：设置分割点，左指针不断移动，直到当前值比分割点大。</span></span><br><span class="line"><span class="comment">  * 右指针不断移动，直到当前值比分割点小</span></span><br><span class="line"><span class="comment">  * 交换左右指针的值，并且left++, right--</span></span><br><span class="line"><span class="comment">  * 直到left&gt;right时，交换分割点和right的值</span></span><br><span class="line"><span class="comment">  * 开启下一次分割</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> sortArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">quickSort</span> = (<span class="params">left, right</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>;<span class="comment">//left大于right的时候return</span></span><br><span class="line">        <span class="keyword">let</span> tempLeft = left;</span><br><span class="line">        <span class="keyword">let</span> tempRight = right;</span><br><span class="line">        <span class="keyword">let</span> mid = left; <span class="comment">//分割点选择left</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;<span class="comment">//注意left是小于等于right。等于的时候也要判断</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; nums[right] &gt; nums[mid]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= right) &#123;<span class="comment">//只有在left小于right的时候才交换</span></span><br><span class="line">                <span class="keyword">let</span> temp = nums[right];</span><br><span class="line">                nums[right] = nums[left];</span><br><span class="line">                nums[left] = temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> temp = nums[right];</span><br><span class="line">        nums[right] = nums[mid];</span><br><span class="line">        nums[mid] = temp;</span><br><span class="line">        <span class="title function_">quickSort</span>(tempLeft, right-<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">quickSort</span>(right+<span class="number">1</span>, tempRight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">quickSort</span>(<span class="number">0</span>, nums.<span class="property">length</span>-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2. 堆排序"></a>2. 堆排序</h3><ul>
<li>选取最后一个非叶子节点，该非叶子节点的索引为<code>arr.length/2 - 1</code>。调整以该非叶子节点为顶点的堆，使其为大顶堆（注意这里的调整顺序是从上往下的）</li>
<li>依次调整所有的非叶子节点，每次调整非叶子节点的时候，都是调整以该非叶子节点为根的小堆，。这样就可以保证在冒出最大元素的时候，该堆始终是大顶堆</li>
<li>把堆顶元素和堆尾元素交换，</li>
<li>重新调整下一个堆</li>
<li>注意的地方：<ol>
<li>判断是否是大顶堆的时候， 需要把当前节点和孩子节点中较大的交换，需要考虑到当前节点可能没有右孩子，但一定有左孩子，</li>
<li>调整大顶堆的时候是从上往下调整的，for循环（该方法值得借鉴，自己不会）</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码逻辑：</span></span><br><span class="line"><span class="comment"> * 1. 每次交换堆顶和末尾元素算一次，堆排序需要执行nums.length次。</span></span><br><span class="line"><span class="comment"> *    所以首先是一个for循环，调用函数，函数的参数是每次构造堆的长度</span></span><br><span class="line"><span class="comment"> * 2. 构造堆的过程，首先是确定最后一个非叶子节点，调整以该非叶子节点为根的堆，</span></span><br><span class="line"><span class="comment"> *    然后循环遍历所有的非叶子节点。这样才能保证是一个大顶堆</span></span><br><span class="line"><span class="comment"> * 3. 最后就是交换元素就行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">swap</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整以index为堆顶的堆，从上往下，</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">adjust</span> = (<span class="params">index,len</span>) =&gt; &#123;<span class="comment">//index表示要调整的最后一个非叶子节点的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k = index * <span class="number">2</span> + <span class="number">1</span>; k &lt; len; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> maxIndex = nums[index] &gt; nums[k] ? <span class="attr">index</span>: k;</span><br><span class="line">            <span class="keyword">if</span>((k + <span class="number">1</span>) &lt; len &amp;&amp; nums[k + <span class="number">1</span>] &gt; nums[maxIndex]) &#123;</span><br><span class="line">                maxIndex = k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxIndex === index) &#123;    <span class="comment">//已经是大顶堆了，不用调了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;        <span class="comment">//有调动，那么它下面的也要调，所以循环继续</span></span><br><span class="line">                <span class="title function_">swap</span>(maxIndex, index);</span><br><span class="line">                index = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">heapSort</span> = (<span class="params">len</span>) =&gt; &#123;<span class="comment">//len表示当前要调整的堆的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len/<span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//遍历所有的非叶子节点，调整整个堆结构</span></span><br><span class="line">            <span class="title function_">adjust</span>(i,len);</span><br><span class="line">        &#125;<span class="comment">//这一步完成之后，就会得到一个严格的大顶堆，接下来就是交换的操作</span></span><br><span class="line">        <span class="title function_">swap</span>(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;<span class="comment">//堆排序的过程，需要完成nums.length步</span></span><br><span class="line">        <span class="title function_">heapSort</span>(nums.<span class="property">length</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><h3 id="1-求联通数"><a href="#1-求联通数" class="headerlink" title="1. 求联通数"></a>1. 求联通数</h3><ul>
<li>米哈游的笔试题，盲人视角，B和G是相同的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*2. 可以在深度遍历的时候，传入当前的color，只要遍历的color等于当前的color,那么继续遍历，</span></span><br><span class="line"><span class="comment"> *  遍历的终止条件：1.数组索引越界。 2.当前节点标记过  3.当前节点不等于curcolor</span></span><br><span class="line"><span class="comment"> * 如果当前节点等于curcolor，才进行下一步的递归操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> myfun = <span class="keyword">function</span>(<span class="params">arr, n , m</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable constant_">DFS</span> = <span class="keyword">function</span> (<span class="params">dfsArr, i, j, curcolor</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfsArr[i][j] === curcolor) &#123;<span class="comment">//等于当前颜色，才进行递归搜索</span></span><br><span class="line">            dfsArr[i][j] = <span class="string">&quot;-1&quot;</span>;<span class="comment">//标记</span></span><br><span class="line">            <span class="title function_">DFS</span>(dfsArr, i + <span class="number">1</span>, j, curcolor);</span><br><span class="line">            <span class="title function_">DFS</span>(dfsArr, i - <span class="number">1</span>, j, curcolor);</span><br><span class="line">            <span class="title function_">DFS</span>(dfsArr, i, j + <span class="number">1</span>, curcolor);</span><br><span class="line">            <span class="title function_">DFS</span>(dfsArr, i, j + <span class="number">1</span>, curcolor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BGRcount</span> = <span class="number">0</span>, <span class="title class_">BGcount</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BGArr</span> = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">row</span>) =&gt;</span> row.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v === <span class="string">&quot;G&quot;</span> ? <span class="string">&quot;B&quot;</span> : v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求联通数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] !== <span class="string">&quot;-1&quot;</span>) &#123;<span class="comment">//只要没有被标记，就深度优先搜索，联通数就加1</span></span><br><span class="line">                <span class="title function_">DFS</span>(arr, i, j, arr[i][j]);</span><br><span class="line">                <span class="title class_">BGRcount</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">BGArr</span>[i][j] !== <span class="string">&quot;-1&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_">DFS</span>(<span class="title class_">BGArr</span>, i, j, <span class="title class_">BGArr</span>[i][j]);</span><br><span class="line">                <span class="title class_">BGcount</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">BGRcount</span> - <span class="title class_">BGcount</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&quot;R&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>], [<span class="string">&quot;R&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;R&quot;</span>]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myfun</span>(arr,<span class="number">2</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<h3 id="2-岛屿的周长"><a href="#2-岛屿的周长" class="headerlink" title="2. 岛屿的周长"></a>2. 岛屿的周长</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 神奇的问题：深度优先遍历，上下左右四个地方都会访问。当深度遍历停止的时候，也就是分两种情况</span></span><br><span class="line"><span class="comment"> * 一是因为超出网格边界，遇到黄色的边，这种情况，周长+1</span></span><br><span class="line"><span class="comment"> * 二是因为遇到已标记过的点，中间的，周长不变，返回0</span></span><br><span class="line"><span class="comment"> * 三是grid为0，遇到海洋，这就是蓝色的边，周长+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> islandPerimeter = <span class="keyword">function</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dfs = <span class="keyword">function</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.<span class="property">length</span> || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//超范围，黄色边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] === <span class="number">0</span>) &#123;<span class="comment">//海洋，蓝色的边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] === <span class="number">2</span>) &#123;<span class="comment">//已标记过，无边</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dfs</span>(i + <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i - <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i, j-<span class="number">1</span>) + <span class="title function_">dfs</span>(i, j+<span class="number">1</span>);<span class="comment">//返回周长</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                result += <span class="title function_">dfs</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul>
<li>取反运算符：<code>~</code>， 异或运算符： <code>^</code>, 左移数翻倍：<code>&lt;&lt;</code>,  右移数减半： <code>&gt;&gt;</code></li>
</ul>
<h3 id="1-只出现一次的数字"><a href="#1-只出现一次的数字" class="headerlink" title="1. 只出现一次的数字"></a>1. 只出现一次的数字</h3><ul>
<li><p>恰好只有一个元素出现一次</p>
</li>
<li><p>位运算。相同的两个数按位异或得到的是0，0和任何数异或得到的是它本身。那么所有的数异或后得到的结果一定是最终的只出现一次的元素</p>
</li>
<li><pre><code class="js">var singleNumber = function(nums) &#123;
    //方法二：位运算。相同的两个数按位异或得到的是0，0和任何数异或得到的是它本身。那么所有的数异或后得到的结果一定是最终的只出现一次的元素
    let result = 0;
    for(let i = 0; i &lt; nums.length; i++) &#123;
        result ^= nums[i];
    &#125;
    return result;

&#125;;
</code></pre>
</li>
</ul>
<h3 id="2-只出现一次的两个数字"><a href="#2-只出现一次的两个数字" class="headerlink" title="2. 只出现一次的两个数字"></a>2. 只出现一次的两个数字</h3><ul>
<li>恰好只有两个元素只出现一次</li>
<li>位运算：所有的数异或之后，可以得到<code>a</code>和<code>b</code>的异或结果，由于a和b不相等，所以异或结果不为0，那么异或结果一定有1。那么a和b一定有一位，一个取1，一个取0。按照这个不同位，将原数分为两个集合。一类是该位取1，一类是该位取0。那么这两个集合中，各自异或的最终结果就是a和b的值</li>
<li></li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><ul>
<li>js中，把其它进制转换成10进制：<code>parseInt(num, 8), parseInt(num, 2), parseInt(num, 16)</code>，第二个参数表示该数本身的进制数</li>
<li>把10进制转换成其它进制：<code>num.toString(2), num.toString(8), num.toString(16)</code></li>
</ul>
<h2 id="差分-前缀和"><a href="#差分-前缀和" class="headerlink" title="差分&amp;前缀和"></a>差分&amp;前缀和</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：在重叠区间内，所有的重叠区间的人数加起来小于等于capcacity，就返回true.</span></span><br><span class="line"><span class="comment"> * 需要考虑每个站点的人数，使用差分数组，差分数组的前缀和就是每个站点的人数。同时对差分数组进行区间加和区间减的操作就可以处理每个区间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> carPooling = <span class="keyword">function</span>(<span class="params">trips, capacity</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1002</span>).<span class="title function_">fill</span>(<span class="number">0</span>);<span class="comment">//注意差分数组的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; trips.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        nums[trips[i][<span class="number">1</span>]] += trips[i][<span class="number">0</span>];</span><br><span class="line">        nums[trips[i][<span class="number">2</span>] ] -= trips[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//差分数组的前缀和就是容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;  <span class="comment">//这里从索引1开始比较，所以需要额外判断nums[0]和capacity的代销</span></span><br><span class="line">        nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="1-小于当前数字的个数"><a href="#1-小于当前数字的个数" class="headerlink" title="1. 小于当前数字的个数"></a>1. 小于当前数字的个数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路：数组排完序之后，数组的索引就是答案</span></span><br><span class="line"><span class="comment"> * 需考虑的情况：</span></span><br><span class="line"><span class="comment"> *  1. 数组排完序之后，顺序乱了，需要按原来顺序返回答案。</span></span><br><span class="line"><span class="comment"> *     使用哈希表（本题数据范围限制100以内，可以使用数组）</span></span><br><span class="line"><span class="comment"> *     key是值，value是索引，这样就记录了数组值和它索引的对应情况（注意这里相同数组的话，索引会被覆盖的）</span></span><br><span class="line"><span class="comment"> *     所以最后result是从hash数组中取值的</span></span><br><span class="line"><span class="comment"> *  2. 数组中可能有相同元素，应该以左边第一个元素的值作为答案放入hash数组中</span></span><br><span class="line"><span class="comment"> *     所以对数组的遍历，应当采用从后往前的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> smallerNumbersThanCurrent = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(nums);</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = nums.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        hash[nums[i]] = i;  <span class="comment">//从后往前遍历，拿到数组值和索引的对应关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        result[i] = hash[arr[i]];<span class="comment">//从hash数组中拿到结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-链表内指定区间反转"><a href="#2-链表内指定区间反转" class="headerlink" title="2. 链表内指定区间反转"></a>2. 链表内指定区间反转</h3><ul>
<li>画图操作</li>
<li>注意虚拟头节点的设置，是为了使得头节点和普通节点一样操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseBetween</span>(<span class="params"> head ,  m ,  n </span>) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);<span class="comment">//设置虚拟头节点，为了防止m=1的情况，将头节点作为普通节点对待，最后返回dummyNode.next</span></span><br><span class="line">    dummyNode.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">let</span> curNode, preNode = dummyNode;</span><br><span class="line">    <span class="keyword">let</span> count = n - m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(--m) &#123;    <span class="comment">//preNode指向m的前一个节点</span></span><br><span class="line">        preNode = preNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> leftNode = preNode.<span class="property">next</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> rightNode = leftNode;</span><br><span class="line">    <span class="keyword">while</span>(--count) &#123;    <span class="comment">//rightNode指向反转链表的最后一个节点</span></span><br><span class="line">        rightNode = rightNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curNode = rightNode.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">    preNode.<span class="property">next</span> = <span class="literal">null</span>;    <span class="comment">//切断链表</span></span><br><span class="line">    rightNode.<span class="property">next</span> = nu</span><br><span class="line">    <span class="keyword">let</span> myreverse = <span class="keyword">function</span>(<span class="params">node</span>) &#123;<span class="comment">//反转链表区间</span></span><br><span class="line">        <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> cur = node;</span><br><span class="line">        <span class="keyword">while</span>(cur !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = cur.<span class="property">next</span>;</span><br><span class="line">            cur.<span class="property">next</span> = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">myreverse</span>(leftNode);</span><br><span class="line"></span><br><span class="line">    preNode.<span class="property">next</span> = rightNode;<span class="comment">//连接链表</span></span><br><span class="line">    leftNode.<span class="property">next</span> = curNode;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h2><h3 id="1-大数加法"><a href="#1-大数加法" class="headerlink" title="1. 大数加法"></a>1. 大数加法</h3><ul>
<li>使用栈，从后往前逐个数字相加，注意进位</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solve</span>(<span class="params"> s ,  t </span>) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> i = s.<span class="property">length</span> -<span class="number">1</span>, j = t.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> jin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= -<span class="number">1</span>) a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> a =  <span class="built_in">parseInt</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(j &lt;= -<span class="number">1</span>) b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> b = <span class="built_in">parseInt</span>(t[j]);</span><br><span class="line">        <span class="keyword">let</span> add = a + b + jin;</span><br><span class="line">        jin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(add &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            jin = <span class="title class_">Math</span>.<span class="title function_">floor</span>(add/<span class="number">10</span>);</span><br><span class="line">            stack.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(add%<span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(add);</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(jin !== <span class="number">0</span>) stack.<span class="title function_">push</span>(jin);</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><ol>
<li><p><strong>有序数组的两数和：</strong>在有序数组中找出两个数，使它们的和为target。</p>
<blockquote>
<p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
</blockquote>
</li>
<li><p><strong>两数平方和</strong>：判断一个非负整数是否为两个整数的平方和。</p>
<blockquote>
<p>双指针，左指针从0开始，右指针从target的根号开始，应用sqrt函数开根号。sum&#x3D;left*left+right+right。分三种情况：</p>
<ul>
<li>sum&#x3D;&#x3D;target。返回true</li>
<li>sum&gt;target。right–</li>
<li>sum&lt;target。left++</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">judgeSquareSum</span>(<span class="params">int c</span>) &#123;</span><br><span class="line">        int i=<span class="number">0</span>;</span><br><span class="line">        long j=<span class="title function_">sqrt</span>(c);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            long sum=i*i+j*j;</span><br><span class="line">            <span class="keyword">if</span>(sum==c)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;c)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;数据结构</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>存在重复元素</strong>：有一整数数组，如果任一值在数组中出现至少两次，返回true，否则false</p>
<ul>
<li><p>题解：将数据进行排序后，比较相邻元素是否相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    bool <span class="title function_">containsDuplicate</span>(<span class="params">vector&lt;int&gt;&amp; nums</span>) &#123;</span><br><span class="line">        <span class="title function_">sort</span>(nums.<span class="title function_">begin</span>(),nums.<span class="title function_">end</span>());       </span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;nums.<span class="title function_">size</span>()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意点：使用标准模板库的sort函数对向量容器进行排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sort</span>(nums.<span class="title function_">begin</span>(),nums.<span class="title function_">end</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>最大子数组和</strong>：给出一个整数数组，找出一个具有最大和的连续子数组，返回其最大和（子数组最少包含一个元素）（Maximum Subarray）</p>
<ul>
<li><p>题解：动态规划的方法，用$f(i)$代表以第$i$个数结尾的连续子数组的最大和，只需要求出每个位置的$f(i)$，然后返回$f$数组中的最大值。</p>
</li>
<li><p>$$<br>max_{0&lt;&#x3D;i&lt;n}f(i)<br>$$</p>
</li>
<li><p>每一个$f(i)$由$f(i-1)$得出</p>
</li>
<li><p>$$<br>f(i)&#x3D;max(f(i-1)+nums[i],nums[i])<br>$$</p>
<p>代码如下：</p>
</li>
</ul>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    int <span class="title function_">maxSubArray</span>(<span class="params">vector&lt;int&gt;&amp; nums</span>) &#123;</span><br><span class="line">        int pre=nums[<span class="number">0</span>];</span><br><span class="line">        int maxRes=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;nums.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            pre= <span class="title function_">max</span>(nums[i]+pre,nums[i]);</span><br><span class="line">           maxRes=<span class="title function_">max</span>(pre,maxRes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxRes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>两数之和</strong>：给定一个数组和一个target,返回两个数相加等于target的位置索引</p>
<ul>
<li><p>题解一：两遍循环，时间复杂度$o(n^2)$，空间复杂度$o(1)$</p>
</li>
<li><p>题解二：哈希表，将数据存入哈希表，使得查找数据时的时间复杂度降为$o(1)$。建立哈希表时，以nums[i]为key，以i为值value。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    vector&lt;int&gt; <span class="title function_">twoSum</span>(<span class="params">vector&lt;int&gt;&amp; nums, int target</span>) &#123;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;nums.size()-1;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=i+1;j&lt;nums.size();j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(nums[i]+nums[j]==target)&#123;</span></span><br><span class="line">        <span class="comment">//             return &#123;i,j&#125;;</span></span><br><span class="line">        <span class="comment">//         &#125;          </span></span><br><span class="line">        <span class="comment">//     &#125;     </span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return &#123;&#125;;</span></span><br><span class="line">        map&lt;int,int&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;nums.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            map&lt;int,int&gt;::iterator it=hashmap.<span class="title function_">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=hashmap.<span class="title function_">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap.<span class="title function_">insert</span>(<span class="title function_">make_pair</span>(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>合并两个有序数组</strong>：nums1和nums2是有序数组，将其合并，结果放在nums1中。</p>
<ul>
<li>题解：使用双指针，依次比较nums1和nums2的元素大小放入新的数组result中，最后再将result复制到nums1中，复制采用assign(result.begin(),result.end())方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">merge</span>(<span class="params">vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n</span>) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int i=<span class="number">0</span>,j=<span class="number">0</span>,z=<span class="number">0</span>;</span><br><span class="line">        cout&lt;&lt;nums1[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">                result.<span class="title function_">push_back</span>(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&gt;nums2[j])&#123;</span><br><span class="line">                result.<span class="title function_">push_back</span>(nums2[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.<span class="title function_">push_back</span>(nums1[i]);</span><br><span class="line">                result.<span class="title function_">push_back</span>(nums2[j]);</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">            result.<span class="title function_">push_back</span>(nums1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            result.<span class="title function_">push_back</span>(nums2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums1.<span class="title function_">assign</span>(result.<span class="title function_">begin</span>(),result.<span class="title function_">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>两个数组的交集</strong>：给定两个数组nums1和nums2，以数组的形式返回两数组的交集。</p>
<ul>
<li><p>题解一：采用哈希表的方法，为nums1数组建立哈希表，key为数字，value为出现的次数。遍历nums2中，在哈希表中查找是是否存在。注意使用哈希表map的find(key)函数,返回迭代器指针。</p>
</li>
<li><p>题解二：将nums1和nums2排序，再用双指针，依次比较数字的大小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    vector&lt;int&gt; <span class="title function_">intersect</span>(<span class="params">vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2</span>) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        map&lt;int,int&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;nums1.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            map&lt;int,int&gt;::iterator it=m.<span class="title function_">find</span>(nums1[i]);</span><br><span class="line">            <span class="keyword">if</span>(it==m.<span class="title function_">end</span>())&#123;</span><br><span class="line">                m.<span class="title function_">insert</span>(<span class="title function_">make_pair</span>(nums1[i],<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m[nums1[i]]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;nums2.<span class="title function_">size</span>();j++)&#123;</span><br><span class="line">            map&lt;int,int&gt;::iterator it=m.<span class="title function_">find</span>(nums2[j]);</span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="title function_">end</span>()&amp;&amp;it-&gt;second!=<span class="number">0</span>)&#123;</span><br><span class="line">                result.<span class="title function_">push_back</span>(nums2[j]);</span><br><span class="line">                it-&gt;second-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>买卖股票的最佳时机</strong>：给定一个数组price，第i个元素price[i]表示股票第i天的价格，评估买卖股票获取的最大利润。</p>
<ul>
<li><p>题解：第i天的最大利润，是由在第i天前的最低价格和最高价格之间的差决定的，所以遍历一次数组，在遍历过程中，用一个变量存储最低价格。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    int <span class="title function_">maxProfit</span>(<span class="params">vector&lt;int&gt;&amp; prices</span>) &#123;</span><br><span class="line">        int minprice=prices[<span class="number">0</span>];</span><br><span class="line">        int maxprofit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;prices.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            maxprofit=<span class="title function_">max</span>(maxprofit,prices[i]-minprice);</span><br><span class="line">            minprice=<span class="title function_">min</span>(minprice,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>重塑矩阵</strong>：将一个$m<em>n$行的二维矩阵编程另一个$r</em>c$行的二维矩阵。</p>
<ul>
<li>题解：考虑一维矩阵的坐标和二维矩阵坐标之间的变换关系。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; <span class="title function_">matrixReshape</span>(<span class="params">vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c</span>) &#123;</span><br><span class="line">        int rowNum=mat.<span class="title function_">size</span>();</span><br><span class="line">        int colNum=mat[<span class="number">0</span>].<span class="title function_">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(rowNum*colNum!=r*c)&#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; <span class="title function_">result</span>(r,vector&lt;int&gt;(c));</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;rowNum*colNum;i++)&#123;</span><br><span class="line">            result[i/c][i%c]=mat[i/colNum][i%colNum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>杨辉三角</strong>：给出杨辉三角的行数，给出杨辉三角每一行的值</p>
<ul>
<li>题解：杨辉三角是一个对称的结构，每一行两边值是1</li>
<li>下一行等于上一行两个数的和</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; <span class="title function_">generate</span>(<span class="params">int numRows</span>) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; <span class="title function_">result</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            result[i].<span class="title function_">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">            result[i][<span class="number">0</span>]=result[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">                result[i][j]=result[i-<span class="number">1</span>][j-<span class="number">1</span>]+result[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>有效数独</strong>：数字1-9在每一行、每一列、每一个小3*3宫格内只能出现一次。</p>
<ul>
<li>题解：为每一行的数字1-9建立哈希表，数组哈希表，表示第i行数字1-9出现的次数，9行9列</li>
<li>为每一列的数字1-9建立数组哈希表，表示第j列数字1-9出现的次数，9行9列</li>
<li>为每一个3<em>3的宫格建立数组哈希表，三维数组，3</em>3*9</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    bool <span class="title function_">isValidSudoku</span>(<span class="params">vector&lt;vector&lt;char&gt;&gt;&amp; board</span>) &#123;</span><br><span class="line">        int rows[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        int cols[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        int s[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="title function_">memset</span>(rows,<span class="number">0</span>,<span class="title function_">sizeof</span>(rows));</span><br><span class="line">        <span class="title function_">memset</span>(cols,<span class="number">0</span>,<span class="title function_">sizeof</span>(cols));</span><br><span class="line">        <span class="title function_">memset</span>(s,<span class="number">0</span>,<span class="title function_">sizeof</span>(s));</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                char c=board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(c!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    int index=c-<span class="string">&#x27;0&#x27;</span>-<span class="number">1</span>;</span><br><span class="line">                    rows[i][index]++;</span><br><span class="line">                    cols[j][index]++;</span><br><span class="line">                    s[i/<span class="number">3</span>][j/<span class="number">3</span>][index]++;</span><br><span class="line">                    <span class="keyword">if</span>(rows[i][index]&gt;<span class="number">1</span>||cols[j][index]&gt;<span class="number">1</span>||s[i/<span class="number">3</span>][j/<span class="number">3</span>][index]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;&#125;&#125;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>字符串</p>
<ol>
<li><p><strong>字符串中的第一个唯一字符</strong>：给定一个字符串s，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回-1。</p>
<ul>
<li>题解：使用哈希表存储频数，</li>
<li>第一次遍历，构建每个字符出现的频数的哈希表。</li>
<li>第二次遍历，查看频数是否为1。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    int <span class="title function_">firstUniqChar</span>(<span class="params">string s</span>) &#123;</span><br><span class="line">        map&lt;int,int&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(char c : s)&#123;</span><br><span class="line">            hashmap[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;s.<span class="title function_">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap[s[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://ddc-hust.github.io">初澈</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://ddc-hust.github.io/2024/06/09/leetcode/">https://ddc-hust.github.io/2024/06/09/leetcode/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/05/03/java/" title="java编程入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">java编程入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">初澈</div><div class="author-info__description">天空很蓝，阳光很暖，花花很美</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">JS知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JS%E9%99%A4%E6%B3%95%E2%80%9C-%E2%80%9D"><span class="toc-number">1.1.</span> <span class="toc-text">1. JS除法“&#x2F;”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-js%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">2. js数组排序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-js%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">3. js创建二维数组：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-js%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.</span> <span class="toc-text">4. js数组拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">1.5.</span> <span class="toc-text">5. 字符编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">8. 生成随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">9. 正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%A1%AE%E5%AE%9A%E5%B7%A6%E5%8F%B3%E8%BE%B9%E7%95%8C"><span class="toc-number">1.8.</span> <span class="toc-text">二分查找确定左右边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.9.</span> <span class="toc-text">2. 移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84209"><span class="toc-number">1.10.</span> <span class="toc-text">3. 长度最小的子数组209</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE904"><span class="toc-number">1.11.</span> <span class="toc-text">4. 水果成篮904</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B276"><span class="toc-number">1.12.</span> <span class="toc-text">5. 最小覆盖子串76</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">1.13.</span> <span class="toc-text">6. 螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.14.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">1. 移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2. 设计链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3. 翻转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">重排链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">4. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">5. 删除链表倒数第n个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">2.7.</span> <span class="toc-text">6. 链表相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.8.</span> <span class="toc-text">7. 环形链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">2.9.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">3.1.</span> <span class="toc-text">1. 有效的字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">3.2.</span> <span class="toc-text">2. 两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">4. 最长连续序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.4.</span> <span class="toc-text">2. 左旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="toc-number">3.5.</span> <span class="toc-text">3. 找出字符串中第一个匹配项的下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">3.6.</span> <span class="toc-text">4. 替换空格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">4.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.1.</span> <span class="toc-text">1. 三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.2.</span> <span class="toc-text">2. 四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3. 快乐数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">1. 匹配问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">5.2.</span> <span class="toc-text">2. 有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">5.3.</span> <span class="toc-text">2. 优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">5.4.</span> <span class="toc-text">3. 滑动窗口最大值(单调队列)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">5.5.</span> <span class="toc-text">4. 前K个高频元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.1.</span> <span class="toc-text">1. 前中后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.2.</span> <span class="toc-text">2. 层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.3.</span> <span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">6.5.</span> <span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">6.6.</span> <span class="toc-text">左叶子之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">6.7.</span> <span class="toc-text">找树左下角的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">6.8.</span> <span class="toc-text">路径总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%92%E5%BD%92%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.9.</span> <span class="toc-text">3. 递归的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.10.</span> <span class="toc-text">4. 构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.11.</span> <span class="toc-text">5. 二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.11.1.</span> <span class="toc-text">1. 验证二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number">6.11.2.</span> <span class="toc-text">2. 二叉搜索树中的最小绝对差</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">6.12.</span> <span class="toc-text">6. 最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A7%8D%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">6.13.</span> <span class="toc-text">二叉搜索树种的插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9450"><span class="toc-number">6.14.</span> <span class="toc-text">7. 删除二叉搜索树中的节点450</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.15.</span> <span class="toc-text">8. 修剪二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.16.</span> <span class="toc-text">9. 有序数组转换成二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">11.恢复二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">7.1.</span> <span class="toc-text">2. 电话号码字母数字的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2"><span class="toc-number">7.2.</span> <span class="toc-text">分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">7.3.</span> <span class="toc-text">4. 分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number">7.4.</span> <span class="toc-text">5. 复原IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">7.5.</span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B1%82%E5%AD%90%E9%9B%86%E4%B8%AA%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">6. 求子集个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%88%97"><span class="toc-number">7.7.</span> <span class="toc-text">排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">7.8.</span> <span class="toc-text">8. 全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%85%A8%E6%8E%92%E5%88%972"><span class="toc-number">7.9.</span> <span class="toc-text">9. 全排列2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">7.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">8.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">8.1.</span> <span class="toc-text">1. 斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">8.2.</span> <span class="toc-text">2. 整数拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA"><span class="toc-number">8.3.</span> <span class="toc-text">0-1背包理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">8.4.</span> <span class="toc-text">3. 分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F"><span class="toc-number">8.5.</span> <span class="toc-text">4. 最后一块石头的重量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">8.6.</span> <span class="toc-text">5. 目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.7.</span> <span class="toc-text">不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">8.8.</span> <span class="toc-text">6. 一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93"><span class="toc-number">8.9.</span> <span class="toc-text">01背包总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">8.10.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">8.11.</span> <span class="toc-text">7. 零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">8.12.</span> <span class="toc-text">8. 组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">8.13.</span> <span class="toc-text">9. 单词拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2"><span class="toc-number">8.14.</span> <span class="toc-text">11. 打家劫舍2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3"><span class="toc-number">8.15.</span> <span class="toc-text">12. 打家劫舍3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">8.16.</span> <span class="toc-text">13. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2"><span class="toc-number">8.17.</span> <span class="toc-text">14. 买卖股票最佳时机2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA3"><span class="toc-number">8.18.</span> <span class="toc-text">15. 买卖股票的最佳时机3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA4"><span class="toc-number">8.19.</span> <span class="toc-text">16. 买卖股票的最佳时机4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA-%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number">8.20.</span> <span class="toc-text">17. 买卖股票时机-含冷冻期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA-%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number">8.21.</span> <span class="toc-text">18.买卖股票时机-含手续费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">8.22.</span> <span class="toc-text">股票问题总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.23.</span> <span class="toc-text">19. 最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.24.</span> <span class="toc-text">20. 最长连续递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">8.25.</span> <span class="toc-text">21. 最长重复子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.26.</span> <span class="toc-text">22. 最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">8.27.</span> <span class="toc-text">23. 最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.28.</span> <span class="toc-text">24. 判断子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%B8%8D%E5%90%8C%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.29.</span> <span class="toc-text">25. 不同子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">8.30.</span> <span class="toc-text">26. 编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%81%E5%AD%90%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93"><span class="toc-number">8.31.</span> <span class="toc-text">子序列、子数组总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">8.32.</span> <span class="toc-text">回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">8.33.</span> <span class="toc-text">最长回文子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E5%8F%91%E5%B0%8F%E9%A5%BC%E5%B9%B2"><span class="toc-number">9.1.</span> <span class="toc-text">1. 分发小饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number">9.2.</span> <span class="toc-text">2. 摆动序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">9.3.</span> <span class="toc-text">3. 最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2"><span class="toc-number">9.4.</span> <span class="toc-text">4. 买卖股票的最佳时机2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">9.5.</span> <span class="toc-text">5. 跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F2"><span class="toc-number">9.6.</span> <span class="toc-text">6. 跳跃游戏2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-k%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">9.7.</span> <span class="toc-text">7. k次取反后最大化数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">9.8.</span> <span class="toc-text">8. 加油站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">9.9.</span> <span class="toc-text">9. 分发糖果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number">9.10.</span> <span class="toc-text">10. 根据身高重建队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">9.11.</span> <span class="toc-text">11. 用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">9.12.</span> <span class="toc-text">12. 无重叠区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">9.13.</span> <span class="toc-text">13. 合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">9.14.</span> <span class="toc-text">14. 单调递增的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.15.</span> <span class="toc-text">16.监控二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%8C%81%E4%BA%BA%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">主持人调度问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE"><span class="toc-number">10.1.</span> <span class="toc-text">面试题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">11.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">11.1.</span> <span class="toc-text">1. 快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">11.2.</span> <span class="toc-text">2. 堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">岛屿问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B1%82%E8%81%94%E9%80%9A%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text">1. 求联通数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF"><span class="toc-number">12.2.</span> <span class="toc-text">2. 岛屿的周长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">13.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">13.1.</span> <span class="toc-text">1. 只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">13.2.</span> <span class="toc-text">2. 只出现一次的两个数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.</span> <span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">15.</span> <span class="toc-text">差分&amp;前缀和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">16.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">16.1.</span> <span class="toc-text">1. 小于当前数字的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC"><span class="toc-number">16.2.</span> <span class="toc-text">2. 链表内指定区间反转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E7%BD%91"><span class="toc-number">17.</span> <span class="toc-text">牛客网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95"><span class="toc-number">17.1.</span> <span class="toc-text">1. 大数加法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%BA%BF"><span class="toc-number">18.</span> <span class="toc-text">分割线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">19.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-number">19.1.</span> <span class="toc-text">双指针</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/09/leetcode/" title="算法">算法</a><time datetime="2024-06-09T06:06:50.231Z" title="Created 2024-06-09 14:06:50">2024-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/03/java/" title="java编程入门">java编程入门</a><time datetime="2024-05-03T09:31:26.000Z" title="Created 2024-05-03 17:31:26">2024-05-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/03/html/" title="html">html</a><time datetime="2024-05-03T02:21:54.000Z" title="Created 2024-05-03 10:21:54">2024-05-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/03/css/" title="css">css</a><time datetime="2024-05-03T02:20:08.000Z" title="Created 2024-05-03 10:20:08">2024-05-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/03/javascript/" title="javascript">javascript</a><time datetime="2024-05-03T02:15:47.000Z" title="Created 2024-05-03 10:15:47">2024-05-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 初澈</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>